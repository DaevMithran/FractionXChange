// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package tokenv1

import (
	_ "cosmossdk.io/api/amino"
	_ "cosmossdk.io/api/cosmos/msg/v1"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_MsgUpdateParams           protoreflect.MessageDescriptor
	fd_MsgUpdateParams_authority protoreflect.FieldDescriptor
	fd_MsgUpdateParams_params    protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateParams = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateParams")
	fd_MsgUpdateParams_authority = md_MsgUpdateParams.Fields().ByName("authority")
	fd_MsgUpdateParams_params = md_MsgUpdateParams.Fields().ByName("params")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateParams)(nil)

type fastReflection_MsgUpdateParams MsgUpdateParams

func (x *MsgUpdateParams) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateParams)(x)
}

func (x *MsgUpdateParams) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateParams_messageType fastReflection_MsgUpdateParams_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateParams_messageType{}

type fastReflection_MsgUpdateParams_messageType struct{}

func (x fastReflection_MsgUpdateParams_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateParams)(nil)
}
func (x fastReflection_MsgUpdateParams_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParams)
}
func (x fastReflection_MsgUpdateParams_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParams
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateParams) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParams
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateParams) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateParams_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateParams) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParams)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateParams) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateParams)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateParams) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Authority != "" {
		value := protoreflect.ValueOfString(x.Authority)
		if !f(fd_MsgUpdateParams_authority, value) {
			return
		}
	}
	if x.Params != nil {
		value := protoreflect.ValueOfMessage(x.Params.ProtoReflect())
		if !f(fd_MsgUpdateParams_params, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateParams) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateParams.authority":
		return x.Authority != ""
	case "mantrachain.token.v1.MsgUpdateParams.params":
		return x.Params != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateParams.authority":
		x.Authority = ""
	case "mantrachain.token.v1.MsgUpdateParams.params":
		x.Params = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateParams) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateParams.authority":
		value := x.Authority
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateParams.params":
		value := x.Params
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParams does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateParams.authority":
		x.Authority = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateParams.params":
		x.Params = value.Message().Interface().(*Params)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateParams.params":
		if x.Params == nil {
			x.Params = new(Params)
		}
		return protoreflect.ValueOfMessage(x.Params.ProtoReflect())
	case "mantrachain.token.v1.MsgUpdateParams.authority":
		panic(fmt.Errorf("field authority of message mantrachain.token.v1.MsgUpdateParams is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateParams) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateParams.authority":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateParams.params":
		m := new(Params)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParams"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParams does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateParams) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateParams", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateParams) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParams) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateParams) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateParams) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateParams)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Authority)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Params != nil {
			l = options.Size(x.Params)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParams)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Params != nil {
			encoded, err := options.Marshal(x.Params)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Authority) > 0 {
			i -= len(x.Authority)
			copy(dAtA[i:], x.Authority)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Authority)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParams)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Authority = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Params == nil {
					x.Params = &Params{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Params); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateParamsResponse protoreflect.MessageDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateParamsResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateParamsResponse")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateParamsResponse)(nil)

type fastReflection_MsgUpdateParamsResponse MsgUpdateParamsResponse

func (x *MsgUpdateParamsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateParamsResponse)(x)
}

func (x *MsgUpdateParamsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateParamsResponse_messageType fastReflection_MsgUpdateParamsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateParamsResponse_messageType{}

type fastReflection_MsgUpdateParamsResponse_messageType struct{}

func (x fastReflection_MsgUpdateParamsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateParamsResponse)(nil)
}
func (x fastReflection_MsgUpdateParamsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParamsResponse)
}
func (x fastReflection_MsgUpdateParamsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParamsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateParamsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateParamsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateParamsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateParamsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateParamsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateParamsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateParamsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateParamsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateParamsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateParamsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateParamsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParamsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateParamsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateParamsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateParamsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateParamsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateParamsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateParamsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateParamsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateParamsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateParamsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateParamsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParamsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateParamsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateRestrictedCollectionNftImage                    protoreflect.MessageDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_creator            protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_owner              protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_collection_creator protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_collection_id      protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_nft_id             protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_index              protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImage_image              protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateRestrictedCollectionNftImage = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateRestrictedCollectionNftImage")
	fd_MsgUpdateRestrictedCollectionNftImage_creator = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("creator")
	fd_MsgUpdateRestrictedCollectionNftImage_owner = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("owner")
	fd_MsgUpdateRestrictedCollectionNftImage_collection_creator = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("collection_creator")
	fd_MsgUpdateRestrictedCollectionNftImage_collection_id = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("collection_id")
	fd_MsgUpdateRestrictedCollectionNftImage_nft_id = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("nft_id")
	fd_MsgUpdateRestrictedCollectionNftImage_index = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("index")
	fd_MsgUpdateRestrictedCollectionNftImage_image = md_MsgUpdateRestrictedCollectionNftImage.Fields().ByName("image")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateRestrictedCollectionNftImage)(nil)

type fastReflection_MsgUpdateRestrictedCollectionNftImage MsgUpdateRestrictedCollectionNftImage

func (x *MsgUpdateRestrictedCollectionNftImage) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImage)(x)
}

func (x *MsgUpdateRestrictedCollectionNftImage) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType{}

type fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType struct{}

func (x fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImage)(nil)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImage)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImage
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImage
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateRestrictedCollectionNftImage_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImage)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateRestrictedCollectionNftImage)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_creator, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_owner, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_collection_id, value) {
			return
		}
	}
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_nft_id, value) {
			return
		}
	}
	if x.Index != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Index)
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_index, value) {
			return
		}
	}
	if x.Image != nil {
		value := protoreflect.ValueOfMessage(x.Image.ProtoReflect())
		if !f(fd_MsgUpdateRestrictedCollectionNftImage_image, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.index":
		return x.Index != uint64(0)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image":
		return x.Image != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.index":
		x.Index = uint64(0)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image":
		x.Image = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.index":
		value := x.Index
		return protoreflect.ValueOfUint64(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image":
		value := x.Image
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.index":
		x.Index = value.Uint()
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image":
		x.Image = value.Message().Interface().(*MsgNftImageMetadata)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image":
		if x.Image == nil {
			x.Image = new(MsgNftImageMetadata)
		}
		return protoreflect.ValueOfMessage(x.Image.ProtoReflect())
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.index":
		panic(fmt.Errorf("field index of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.index":
		return protoreflect.ValueOfUint64(uint64(0))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image":
		m := new(MsgNftImageMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImage) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImage)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Index != 0 {
			n += 1 + runtime.Sov(uint64(x.Index))
		}
		if x.Image != nil {
			l = options.Size(x.Image)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImage)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Image != nil {
			encoded, err := options.Marshal(x.Image)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if x.Index != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Index))
			i--
			dAtA[i] = 0x30
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImage)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImage: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImage: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
				}
				x.Index = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Index |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Image == nil {
					x.Image = &MsgNftImageMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Image); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateRestrictedCollectionNftImageResponse                    protoreflect.MessageDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageResponse_nft_id             protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageResponse_owner              protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateRestrictedCollectionNftImageResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateRestrictedCollectionNftImageResponse")
	fd_MsgUpdateRestrictedCollectionNftImageResponse_nft_id = md_MsgUpdateRestrictedCollectionNftImageResponse.Fields().ByName("nft_id")
	fd_MsgUpdateRestrictedCollectionNftImageResponse_owner = md_MsgUpdateRestrictedCollectionNftImageResponse.Fields().ByName("owner")
	fd_MsgUpdateRestrictedCollectionNftImageResponse_collection_creator = md_MsgUpdateRestrictedCollectionNftImageResponse.Fields().ByName("collection_creator")
	fd_MsgUpdateRestrictedCollectionNftImageResponse_collection_id = md_MsgUpdateRestrictedCollectionNftImageResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateRestrictedCollectionNftImageResponse)(nil)

type fastReflection_MsgUpdateRestrictedCollectionNftImageResponse MsgUpdateRestrictedCollectionNftImageResponse

func (x *MsgUpdateRestrictedCollectionNftImageResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageResponse)(x)
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType{}

type fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType struct{}

func (x fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageResponse)(nil)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageResponse)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateRestrictedCollectionNftImageResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateRestrictedCollectionNftImageResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageResponse_nft_id, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageResponse_owner, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateRestrictedCollectionNftImageBatch                    protoreflect.MessageDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatch_creator            protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatch_collection_creator protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatch_collection_id      protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatch_nfts_images        protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateRestrictedCollectionNftImageBatch = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateRestrictedCollectionNftImageBatch")
	fd_MsgUpdateRestrictedCollectionNftImageBatch_creator = md_MsgUpdateRestrictedCollectionNftImageBatch.Fields().ByName("creator")
	fd_MsgUpdateRestrictedCollectionNftImageBatch_collection_creator = md_MsgUpdateRestrictedCollectionNftImageBatch.Fields().ByName("collection_creator")
	fd_MsgUpdateRestrictedCollectionNftImageBatch_collection_id = md_MsgUpdateRestrictedCollectionNftImageBatch.Fields().ByName("collection_id")
	fd_MsgUpdateRestrictedCollectionNftImageBatch_nfts_images = md_MsgUpdateRestrictedCollectionNftImageBatch.Fields().ByName("nfts_images")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateRestrictedCollectionNftImageBatch)(nil)

type fastReflection_MsgUpdateRestrictedCollectionNftImageBatch MsgUpdateRestrictedCollectionNftImageBatch

func (x *MsgUpdateRestrictedCollectionNftImageBatch) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageBatch)(x)
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType{}

type fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType struct{}

func (x fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageBatch)(nil)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageBatch)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageBatch
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageBatch
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateRestrictedCollectionNftImageBatch_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageBatch)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateRestrictedCollectionNftImageBatch)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatch_creator, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatch_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatch_collection_id, value) {
			return
		}
	}
	if x.NftsImages != nil {
		value := protoreflect.ValueOfMessage(x.NftsImages.ProtoReflect())
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatch_nfts_images, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images":
		return x.NftsImages != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images":
		x.NftsImages = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images":
		value := x.NftsImages
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images":
		x.NftsImages = value.Message().Interface().(*MsgNftsImagesMetadata)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images":
		if x.NftsImages == nil {
			x.NftsImages = new(MsgNftsImagesMetadata)
		}
		return protoreflect.ValueOfMessage(x.NftsImages.ProtoReflect())
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images":
		m := new(MsgNftsImagesMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatch) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageBatch)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.NftsImages != nil {
			l = options.Size(x.NftsImages)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageBatch)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.NftsImages != nil {
			encoded, err := options.Marshal(x.NftsImages)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageBatch)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageBatch: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageBatch: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsImages", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.NftsImages == nil {
					x.NftsImages = &MsgNftsImagesMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.NftsImages); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list)(nil)

type _MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list struct {
	list *[]string
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgUpdateRestrictedCollectionNftImageBatchResponse at list field NftsIds as it is not of Message kind"))
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgUpdateRestrictedCollectionNftImageBatchResponse                    protoreflect.MessageDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_nfts_ids           protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_nfts_count         protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateRestrictedCollectionNftImageBatchResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateRestrictedCollectionNftImageBatchResponse")
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_nfts_ids = md_MsgUpdateRestrictedCollectionNftImageBatchResponse.Fields().ByName("nfts_ids")
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_nfts_count = md_MsgUpdateRestrictedCollectionNftImageBatchResponse.Fields().ByName("nfts_count")
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_collection_creator = md_MsgUpdateRestrictedCollectionNftImageBatchResponse.Fields().ByName("collection_creator")
	fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_collection_id = md_MsgUpdateRestrictedCollectionNftImageBatchResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse)(nil)

type fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse MsgUpdateRestrictedCollectionNftImageBatchResponse

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse)(x)
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType{}

type fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType struct{}

func (x fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse)(nil)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageBatchResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageBatchResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateRestrictedCollectionNftImageBatchResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NftsIds) != 0 {
		value := protoreflect.ValueOfList(&_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list{list: &x.NftsIds})
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_nfts_ids, value) {
			return
		}
	}
	if x.NftsCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.NftsCount)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_nfts_count, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageBatchResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_ids":
		return len(x.NftsIds) != 0
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_count":
		return x.NftsCount != uint32(0)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_ids":
		x.NftsIds = nil
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_count":
		x.NftsCount = uint32(0)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_ids":
		if len(x.NftsIds) == 0 {
			return protoreflect.ValueOfList(&_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list{})
		}
		listValue := &_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(listValue)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_count":
		value := x.NftsCount
		return protoreflect.ValueOfUint32(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_ids":
		lv := value.List()
		clv := lv.(*_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list)
		x.NftsIds = *clv.list
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_count":
		x.NftsCount = uint32(value.Uint())
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_ids":
		if x.NftsIds == nil {
			x.NftsIds = []string{}
		}
		value := &_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_count":
		panic(fmt.Errorf("field nfts_count of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_ids":
		list := []string{}
		return protoreflect.ValueOfList(&_MsgUpdateRestrictedCollectionNftImageBatchResponse_1_list{list: &list})
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.nfts_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageBatchResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageBatchResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.NftsIds) > 0 {
			for _, s := range x.NftsIds {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NftsCount != 0 {
			n += 1 + runtime.Sov(uint64(x.NftsCount))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageBatchResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NftsCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NftsCount))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NftsIds) > 0 {
			for iNdEx := len(x.NftsIds) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.NftsIds[iNdEx])
				copy(dAtA[i:], x.NftsIds[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftsIds[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageBatchResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageBatchResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsIds", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftsIds = append(x.NftsIds, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsCount", wireType)
				}
				x.NftsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NftsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateRestrictedCollectionNftImageGroupedBatch                     protoreflect.MessageDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_creator             protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_collection_creator  protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_collection_id       protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_nfts_images_grouped protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateRestrictedCollectionNftImageGroupedBatch = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateRestrictedCollectionNftImageGroupedBatch")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_creator = md_MsgUpdateRestrictedCollectionNftImageGroupedBatch.Fields().ByName("creator")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_collection_creator = md_MsgUpdateRestrictedCollectionNftImageGroupedBatch.Fields().ByName("collection_creator")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_collection_id = md_MsgUpdateRestrictedCollectionNftImageGroupedBatch.Fields().ByName("collection_id")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_nfts_images_grouped = md_MsgUpdateRestrictedCollectionNftImageGroupedBatch.Fields().ByName("nfts_images_grouped")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch)(nil)

type fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch MsgUpdateRestrictedCollectionNftImageGroupedBatch

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch)(x)
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType{}

type fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType struct{}

func (x fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch)(nil)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageGroupedBatch
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageGroupedBatch
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateRestrictedCollectionNftImageGroupedBatch)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_creator, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_collection_id, value) {
			return
		}
	}
	if x.NftsImagesGrouped != nil {
		value := protoreflect.ValueOfMessage(x.NftsImagesGrouped.ProtoReflect())
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatch_nfts_images_grouped, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped":
		return x.NftsImagesGrouped != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped":
		x.NftsImagesGrouped = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped":
		value := x.NftsImagesGrouped
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped":
		x.NftsImagesGrouped = value.Message().Interface().(*MsgNftsImagesGroupedMetadata)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped":
		if x.NftsImagesGrouped == nil {
			x.NftsImagesGrouped = new(MsgNftsImagesGroupedMetadata)
		}
		return protoreflect.ValueOfMessage(x.NftsImagesGrouped.ProtoReflect())
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped":
		m := new(MsgNftsImagesGroupedMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatch) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageGroupedBatch)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.NftsImagesGrouped != nil {
			l = options.Size(x.NftsImagesGrouped)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageGroupedBatch)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.NftsImagesGrouped != nil {
			encoded, err := options.Marshal(x.NftsImagesGrouped)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageGroupedBatch)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageGroupedBatch: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageGroupedBatch: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsImagesGrouped", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.NftsImagesGrouped == nil {
					x.NftsImagesGrouped = &MsgNftsImagesGroupedMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.NftsImagesGrouped); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list)(nil)

type _MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list struct {
	list *[]string
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse at list field NftsIds as it is not of Message kind"))
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse                    protoreflect.MessageDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_nfts_ids           protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_nfts_count         protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_nfts_ids = md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.Fields().ByName("nfts_ids")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_nfts_count = md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.Fields().ByName("nfts_count")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_collection_creator = md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.Fields().ByName("collection_creator")
	fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_collection_id = md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)(nil)

type fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)(x)
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType{}

type fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType struct{}

func (x fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)(nil)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)
}
func (x fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NftsIds) != 0 {
		value := protoreflect.ValueOfList(&_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list{list: &x.NftsIds})
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_nfts_ids, value) {
			return
		}
	}
	if x.NftsCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.NftsCount)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_nfts_count, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_ids":
		return len(x.NftsIds) != 0
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_count":
		return x.NftsCount != uint32(0)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_ids":
		x.NftsIds = nil
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_count":
		x.NftsCount = uint32(0)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_ids":
		if len(x.NftsIds) == 0 {
			return protoreflect.ValueOfList(&_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list{})
		}
		listValue := &_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(listValue)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_count":
		value := x.NftsCount
		return protoreflect.ValueOfUint32(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_ids":
		lv := value.List()
		clv := lv.(*_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list)
		x.NftsIds = *clv.list
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_count":
		x.NftsCount = uint32(value.Uint())
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_ids":
		if x.NftsIds == nil {
			x.NftsIds = []string{}
		}
		value := &_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(value)
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_count":
		panic(fmt.Errorf("field nfts_count of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_ids":
		list := []string{}
		return protoreflect.ValueOfList(&_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse_1_list{list: &list})
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.nfts_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.NftsIds) > 0 {
			for _, s := range x.NftsIds {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NftsCount != 0 {
			n += 1 + runtime.Sov(uint64(x.NftsCount))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NftsCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NftsCount))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NftsIds) > 0 {
			for iNdEx := len(x.NftsIds) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.NftsIds[iNdEx])
				copy(dAtA[i:], x.NftsIds[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftsIds[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsIds", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftsIds = append(x.NftsIds, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsCount", wireType)
				}
				x.NftsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NftsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateGuardSoulBondNftImage         protoreflect.MessageDescriptor
	fd_MsgUpdateGuardSoulBondNftImage_creator protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImage_owner   protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImage_nft_id  protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImage_index   protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImage_image   protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateGuardSoulBondNftImage = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateGuardSoulBondNftImage")
	fd_MsgUpdateGuardSoulBondNftImage_creator = md_MsgUpdateGuardSoulBondNftImage.Fields().ByName("creator")
	fd_MsgUpdateGuardSoulBondNftImage_owner = md_MsgUpdateGuardSoulBondNftImage.Fields().ByName("owner")
	fd_MsgUpdateGuardSoulBondNftImage_nft_id = md_MsgUpdateGuardSoulBondNftImage.Fields().ByName("nft_id")
	fd_MsgUpdateGuardSoulBondNftImage_index = md_MsgUpdateGuardSoulBondNftImage.Fields().ByName("index")
	fd_MsgUpdateGuardSoulBondNftImage_image = md_MsgUpdateGuardSoulBondNftImage.Fields().ByName("image")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateGuardSoulBondNftImage)(nil)

type fastReflection_MsgUpdateGuardSoulBondNftImage MsgUpdateGuardSoulBondNftImage

func (x *MsgUpdateGuardSoulBondNftImage) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateGuardSoulBondNftImage)(x)
}

func (x *MsgUpdateGuardSoulBondNftImage) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateGuardSoulBondNftImage_messageType fastReflection_MsgUpdateGuardSoulBondNftImage_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateGuardSoulBondNftImage_messageType{}

type fastReflection_MsgUpdateGuardSoulBondNftImage_messageType struct{}

func (x fastReflection_MsgUpdateGuardSoulBondNftImage_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateGuardSoulBondNftImage)(nil)
}
func (x fastReflection_MsgUpdateGuardSoulBondNftImage_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateGuardSoulBondNftImage)
}
func (x fastReflection_MsgUpdateGuardSoulBondNftImage_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateGuardSoulBondNftImage
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateGuardSoulBondNftImage
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateGuardSoulBondNftImage_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateGuardSoulBondNftImage)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateGuardSoulBondNftImage)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgUpdateGuardSoulBondNftImage_creator, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgUpdateGuardSoulBondNftImage_owner, value) {
			return
		}
	}
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgUpdateGuardSoulBondNftImage_nft_id, value) {
			return
		}
	}
	if x.Index != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Index)
		if !f(fd_MsgUpdateGuardSoulBondNftImage_index, value) {
			return
		}
	}
	if x.Image != nil {
		value := protoreflect.ValueOfMessage(x.Image.ProtoReflect())
		if !f(fd_MsgUpdateGuardSoulBondNftImage_image, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.index":
		return x.Index != uint64(0)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image":
		return x.Image != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.index":
		x.Index = uint64(0)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image":
		x.Image = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.index":
		value := x.Index
		return protoreflect.ValueOfUint64(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image":
		value := x.Image
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.index":
		x.Index = value.Uint()
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image":
		x.Image = value.Message().Interface().(*MsgNftImageMetadata)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image":
		if x.Image == nil {
			x.Image = new(MsgNftImageMetadata)
		}
		return protoreflect.ValueOfMessage(x.Image.ProtoReflect())
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage is not mutable"))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.index":
		panic(fmt.Errorf("field index of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.index":
		return protoreflect.ValueOfUint64(uint64(0))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image":
		m := new(MsgNftImageMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImage) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateGuardSoulBondNftImage)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Index != 0 {
			n += 1 + runtime.Sov(uint64(x.Index))
		}
		if x.Image != nil {
			l = options.Size(x.Image)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateGuardSoulBondNftImage)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Image != nil {
			encoded, err := options.Marshal(x.Image)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Index != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Index))
			i--
			dAtA[i] = 0x20
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateGuardSoulBondNftImage)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateGuardSoulBondNftImage: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateGuardSoulBondNftImage: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
				}
				x.Index = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Index |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Image == nil {
					x.Image = &MsgNftImageMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Image); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgUpdateGuardSoulBondNftImageResponse                    protoreflect.MessageDescriptor
	fd_MsgUpdateGuardSoulBondNftImageResponse_nft_id             protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImageResponse_owner              protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImageResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgUpdateGuardSoulBondNftImageResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgUpdateGuardSoulBondNftImageResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgUpdateGuardSoulBondNftImageResponse")
	fd_MsgUpdateGuardSoulBondNftImageResponse_nft_id = md_MsgUpdateGuardSoulBondNftImageResponse.Fields().ByName("nft_id")
	fd_MsgUpdateGuardSoulBondNftImageResponse_owner = md_MsgUpdateGuardSoulBondNftImageResponse.Fields().ByName("owner")
	fd_MsgUpdateGuardSoulBondNftImageResponse_collection_creator = md_MsgUpdateGuardSoulBondNftImageResponse.Fields().ByName("collection_creator")
	fd_MsgUpdateGuardSoulBondNftImageResponse_collection_id = md_MsgUpdateGuardSoulBondNftImageResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgUpdateGuardSoulBondNftImageResponse)(nil)

type fastReflection_MsgUpdateGuardSoulBondNftImageResponse MsgUpdateGuardSoulBondNftImageResponse

func (x *MsgUpdateGuardSoulBondNftImageResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgUpdateGuardSoulBondNftImageResponse)(x)
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType{}

type fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType struct{}

func (x fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgUpdateGuardSoulBondNftImageResponse)(nil)
}
func (x fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateGuardSoulBondNftImageResponse)
}
func (x fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateGuardSoulBondNftImageResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgUpdateGuardSoulBondNftImageResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgUpdateGuardSoulBondNftImageResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) New() protoreflect.Message {
	return new(fastReflection_MsgUpdateGuardSoulBondNftImageResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgUpdateGuardSoulBondNftImageResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgUpdateGuardSoulBondNftImageResponse_nft_id, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgUpdateGuardSoulBondNftImageResponse_owner, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgUpdateGuardSoulBondNftImageResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgUpdateGuardSoulBondNftImageResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse is not mutable"))
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgUpdateGuardSoulBondNftImageResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgUpdateGuardSoulBondNftImageResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateGuardSoulBondNftImageResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgUpdateGuardSoulBondNftImageResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateGuardSoulBondNftImageResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgUpdateGuardSoulBondNftImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgApproveNft                    protoreflect.MessageDescriptor
	fd_MsgApproveNft_creator            protoreflect.FieldDescriptor
	fd_MsgApproveNft_receiver           protoreflect.FieldDescriptor
	fd_MsgApproveNft_collection_creator protoreflect.FieldDescriptor
	fd_MsgApproveNft_collection_id      protoreflect.FieldDescriptor
	fd_MsgApproveNft_nft_id             protoreflect.FieldDescriptor
	fd_MsgApproveNft_approved           protoreflect.FieldDescriptor
	fd_MsgApproveNft_strict             protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgApproveNft = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgApproveNft")
	fd_MsgApproveNft_creator = md_MsgApproveNft.Fields().ByName("creator")
	fd_MsgApproveNft_receiver = md_MsgApproveNft.Fields().ByName("receiver")
	fd_MsgApproveNft_collection_creator = md_MsgApproveNft.Fields().ByName("collection_creator")
	fd_MsgApproveNft_collection_id = md_MsgApproveNft.Fields().ByName("collection_id")
	fd_MsgApproveNft_nft_id = md_MsgApproveNft.Fields().ByName("nft_id")
	fd_MsgApproveNft_approved = md_MsgApproveNft.Fields().ByName("approved")
	fd_MsgApproveNft_strict = md_MsgApproveNft.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgApproveNft)(nil)

type fastReflection_MsgApproveNft MsgApproveNft

func (x *MsgApproveNft) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgApproveNft)(x)
}

func (x *MsgApproveNft) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgApproveNft_messageType fastReflection_MsgApproveNft_messageType
var _ protoreflect.MessageType = fastReflection_MsgApproveNft_messageType{}

type fastReflection_MsgApproveNft_messageType struct{}

func (x fastReflection_MsgApproveNft_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgApproveNft)(nil)
}
func (x fastReflection_MsgApproveNft_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNft)
}
func (x fastReflection_MsgApproveNft_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNft
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgApproveNft) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNft
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgApproveNft) Type() protoreflect.MessageType {
	return _fastReflection_MsgApproveNft_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgApproveNft) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNft)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgApproveNft) Interface() protoreflect.ProtoMessage {
	return (*MsgApproveNft)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgApproveNft) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgApproveNft_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgApproveNft_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgApproveNft_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgApproveNft_collection_id, value) {
			return
		}
	}
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgApproveNft_nft_id, value) {
			return
		}
	}
	if x.Approved != false {
		value := protoreflect.ValueOfBool(x.Approved)
		if !f(fd_MsgApproveNft_approved, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgApproveNft_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgApproveNft) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNft.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgApproveNft.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgApproveNft.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgApproveNft.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgApproveNft.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgApproveNft.approved":
		return x.Approved != false
	case "mantrachain.token.v1.MsgApproveNft.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNft does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNft) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNft.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgApproveNft.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgApproveNft.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgApproveNft.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgApproveNft.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgApproveNft.approved":
		x.Approved = false
	case "mantrachain.token.v1.MsgApproveNft.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNft does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgApproveNft) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgApproveNft.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNft.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNft.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNft.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNft.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNft.approved":
		value := x.Approved
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgApproveNft.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNft does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNft) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNft.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNft.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNft.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNft.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNft.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNft.approved":
		x.Approved = value.Bool()
	case "mantrachain.token.v1.MsgApproveNft.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNft does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNft) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNft.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	case "mantrachain.token.v1.MsgApproveNft.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	case "mantrachain.token.v1.MsgApproveNft.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	case "mantrachain.token.v1.MsgApproveNft.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	case "mantrachain.token.v1.MsgApproveNft.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	case "mantrachain.token.v1.MsgApproveNft.approved":
		panic(fmt.Errorf("field approved of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	case "mantrachain.token.v1.MsgApproveNft.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgApproveNft is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNft does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgApproveNft) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNft.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNft.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNft.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNft.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNft.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNft.approved":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgApproveNft.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNft does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgApproveNft) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgApproveNft", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgApproveNft) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNft) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgApproveNft) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgApproveNft) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgApproveNft)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Approved {
			n += 2
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNft)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if x.Approved {
			i--
			if x.Approved {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNft)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNft: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNft: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Approved = bool(v != 0)
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgApproveNftResponse                    protoreflect.MessageDescriptor
	fd_MsgApproveNftResponse_nft_id             protoreflect.FieldDescriptor
	fd_MsgApproveNftResponse_owner              protoreflect.FieldDescriptor
	fd_MsgApproveNftResponse_receiver           protoreflect.FieldDescriptor
	fd_MsgApproveNftResponse_approved           protoreflect.FieldDescriptor
	fd_MsgApproveNftResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgApproveNftResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgApproveNftResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgApproveNftResponse")
	fd_MsgApproveNftResponse_nft_id = md_MsgApproveNftResponse.Fields().ByName("nft_id")
	fd_MsgApproveNftResponse_owner = md_MsgApproveNftResponse.Fields().ByName("owner")
	fd_MsgApproveNftResponse_receiver = md_MsgApproveNftResponse.Fields().ByName("receiver")
	fd_MsgApproveNftResponse_approved = md_MsgApproveNftResponse.Fields().ByName("approved")
	fd_MsgApproveNftResponse_collection_creator = md_MsgApproveNftResponse.Fields().ByName("collection_creator")
	fd_MsgApproveNftResponse_collection_id = md_MsgApproveNftResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgApproveNftResponse)(nil)

type fastReflection_MsgApproveNftResponse MsgApproveNftResponse

func (x *MsgApproveNftResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgApproveNftResponse)(x)
}

func (x *MsgApproveNftResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgApproveNftResponse_messageType fastReflection_MsgApproveNftResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgApproveNftResponse_messageType{}

type fastReflection_MsgApproveNftResponse_messageType struct{}

func (x fastReflection_MsgApproveNftResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgApproveNftResponse)(nil)
}
func (x fastReflection_MsgApproveNftResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNftResponse)
}
func (x fastReflection_MsgApproveNftResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNftResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgApproveNftResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNftResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgApproveNftResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgApproveNftResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgApproveNftResponse) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNftResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgApproveNftResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgApproveNftResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgApproveNftResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgApproveNftResponse_nft_id, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgApproveNftResponse_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgApproveNftResponse_receiver, value) {
			return
		}
	}
	if x.Approved != false {
		value := protoreflect.ValueOfBool(x.Approved)
		if !f(fd_MsgApproveNftResponse_approved, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgApproveNftResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgApproveNftResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgApproveNftResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftResponse.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgApproveNftResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgApproveNftResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgApproveNftResponse.approved":
		return x.Approved != false
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftResponse.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgApproveNftResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgApproveNftResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgApproveNftResponse.approved":
		x.Approved = false
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgApproveNftResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgApproveNftResponse.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftResponse.approved":
		value := x.Approved
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftResponse.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftResponse.approved":
		x.Approved = value.Bool()
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftResponse.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgApproveNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgApproveNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgApproveNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftResponse.approved":
		panic(fmt.Errorf("field approved of message mantrachain.token.v1.MsgApproveNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgApproveNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgApproveNftResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgApproveNftResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftResponse.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftResponse.approved":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgApproveNftResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgApproveNftResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgApproveNftResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgApproveNftResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgApproveNftResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgApproveNftResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Approved {
			n += 2
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNftResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x2a
		}
		if x.Approved {
			i--
			if x.Approved {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNftResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNftResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Approved = bool(v != 0)
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgTransferNft                    protoreflect.MessageDescriptor
	fd_MsgTransferNft_creator            protoreflect.FieldDescriptor
	fd_MsgTransferNft_owner              protoreflect.FieldDescriptor
	fd_MsgTransferNft_receiver           protoreflect.FieldDescriptor
	fd_MsgTransferNft_collection_creator protoreflect.FieldDescriptor
	fd_MsgTransferNft_collection_id      protoreflect.FieldDescriptor
	fd_MsgTransferNft_nft_id             protoreflect.FieldDescriptor
	fd_MsgTransferNft_strict             protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgTransferNft = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgTransferNft")
	fd_MsgTransferNft_creator = md_MsgTransferNft.Fields().ByName("creator")
	fd_MsgTransferNft_owner = md_MsgTransferNft.Fields().ByName("owner")
	fd_MsgTransferNft_receiver = md_MsgTransferNft.Fields().ByName("receiver")
	fd_MsgTransferNft_collection_creator = md_MsgTransferNft.Fields().ByName("collection_creator")
	fd_MsgTransferNft_collection_id = md_MsgTransferNft.Fields().ByName("collection_id")
	fd_MsgTransferNft_nft_id = md_MsgTransferNft.Fields().ByName("nft_id")
	fd_MsgTransferNft_strict = md_MsgTransferNft.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgTransferNft)(nil)

type fastReflection_MsgTransferNft MsgTransferNft

func (x *MsgTransferNft) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgTransferNft)(x)
}

func (x *MsgTransferNft) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgTransferNft_messageType fastReflection_MsgTransferNft_messageType
var _ protoreflect.MessageType = fastReflection_MsgTransferNft_messageType{}

type fastReflection_MsgTransferNft_messageType struct{}

func (x fastReflection_MsgTransferNft_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgTransferNft)(nil)
}
func (x fastReflection_MsgTransferNft_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNft)
}
func (x fastReflection_MsgTransferNft_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNft
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgTransferNft) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNft
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgTransferNft) Type() protoreflect.MessageType {
	return _fastReflection_MsgTransferNft_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgTransferNft) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNft)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgTransferNft) Interface() protoreflect.ProtoMessage {
	return (*MsgTransferNft)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgTransferNft) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgTransferNft_creator, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgTransferNft_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgTransferNft_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgTransferNft_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgTransferNft_collection_id, value) {
			return
		}
	}
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgTransferNft_nft_id, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgTransferNft_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgTransferNft) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNft.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgTransferNft.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgTransferNft.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgTransferNft.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgTransferNft.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgTransferNft.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgTransferNft.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNft does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNft) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNft.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgTransferNft.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgTransferNft.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgTransferNft.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgTransferNft.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgTransferNft.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgTransferNft.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNft does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgTransferNft) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgTransferNft.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNft.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNft.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNft.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNft.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNft.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNft.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNft does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNft) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNft.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNft.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNft.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNft.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNft.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNft.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNft.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNft does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNft) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNft.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	case "mantrachain.token.v1.MsgTransferNft.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	case "mantrachain.token.v1.MsgTransferNft.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	case "mantrachain.token.v1.MsgTransferNft.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	case "mantrachain.token.v1.MsgTransferNft.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	case "mantrachain.token.v1.MsgTransferNft.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	case "mantrachain.token.v1.MsgTransferNft.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgTransferNft is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNft does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgTransferNft) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNft.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNft.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNft.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNft.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNft.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNft.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNft.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNft does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgTransferNft) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgTransferNft", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgTransferNft) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNft) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgTransferNft) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgTransferNft) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgTransferNft)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNft)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNft)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNft: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNft: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgTransferNftResponse                    protoreflect.MessageDescriptor
	fd_MsgTransferNftResponse_nft_id             protoreflect.FieldDescriptor
	fd_MsgTransferNftResponse_operator           protoreflect.FieldDescriptor
	fd_MsgTransferNftResponse_owner              protoreflect.FieldDescriptor
	fd_MsgTransferNftResponse_receiver           protoreflect.FieldDescriptor
	fd_MsgTransferNftResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgTransferNftResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgTransferNftResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgTransferNftResponse")
	fd_MsgTransferNftResponse_nft_id = md_MsgTransferNftResponse.Fields().ByName("nft_id")
	fd_MsgTransferNftResponse_operator = md_MsgTransferNftResponse.Fields().ByName("operator")
	fd_MsgTransferNftResponse_owner = md_MsgTransferNftResponse.Fields().ByName("owner")
	fd_MsgTransferNftResponse_receiver = md_MsgTransferNftResponse.Fields().ByName("receiver")
	fd_MsgTransferNftResponse_collection_creator = md_MsgTransferNftResponse.Fields().ByName("collection_creator")
	fd_MsgTransferNftResponse_collection_id = md_MsgTransferNftResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgTransferNftResponse)(nil)

type fastReflection_MsgTransferNftResponse MsgTransferNftResponse

func (x *MsgTransferNftResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgTransferNftResponse)(x)
}

func (x *MsgTransferNftResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgTransferNftResponse_messageType fastReflection_MsgTransferNftResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgTransferNftResponse_messageType{}

type fastReflection_MsgTransferNftResponse_messageType struct{}

func (x fastReflection_MsgTransferNftResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgTransferNftResponse)(nil)
}
func (x fastReflection_MsgTransferNftResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNftResponse)
}
func (x fastReflection_MsgTransferNftResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNftResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgTransferNftResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNftResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgTransferNftResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgTransferNftResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgTransferNftResponse) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNftResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgTransferNftResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgTransferNftResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgTransferNftResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgTransferNftResponse_nft_id, value) {
			return
		}
	}
	if x.Operator != "" {
		value := protoreflect.ValueOfString(x.Operator)
		if !f(fd_MsgTransferNftResponse_operator, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgTransferNftResponse_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgTransferNftResponse_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgTransferNftResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgTransferNftResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgTransferNftResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftResponse.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgTransferNftResponse.operator":
		return x.Operator != ""
	case "mantrachain.token.v1.MsgTransferNftResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgTransferNftResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftResponse.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgTransferNftResponse.operator":
		x.Operator = ""
	case "mantrachain.token.v1.MsgTransferNftResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgTransferNftResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgTransferNftResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgTransferNftResponse.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftResponse.operator":
		value := x.Operator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftResponse.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftResponse.operator":
		x.Operator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftResponse.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgTransferNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftResponse.operator":
		panic(fmt.Errorf("field operator of message mantrachain.token.v1.MsgTransferNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgTransferNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgTransferNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgTransferNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgTransferNftResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgTransferNftResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftResponse.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftResponse.operator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgTransferNftResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgTransferNftResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgTransferNftResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgTransferNftResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgTransferNftResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgTransferNftResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Operator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNftResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Operator) > 0 {
			i -= len(x.Operator)
			copy(dAtA[i:], x.Operator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Operator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNftResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNftResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Operator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgBurnNft                    protoreflect.MessageDescriptor
	fd_MsgBurnNft_creator            protoreflect.FieldDescriptor
	fd_MsgBurnNft_collection_creator protoreflect.FieldDescriptor
	fd_MsgBurnNft_collection_id      protoreflect.FieldDescriptor
	fd_MsgBurnNft_nft_id             protoreflect.FieldDescriptor
	fd_MsgBurnNft_strict             protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgBurnNft = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgBurnNft")
	fd_MsgBurnNft_creator = md_MsgBurnNft.Fields().ByName("creator")
	fd_MsgBurnNft_collection_creator = md_MsgBurnNft.Fields().ByName("collection_creator")
	fd_MsgBurnNft_collection_id = md_MsgBurnNft.Fields().ByName("collection_id")
	fd_MsgBurnNft_nft_id = md_MsgBurnNft.Fields().ByName("nft_id")
	fd_MsgBurnNft_strict = md_MsgBurnNft.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgBurnNft)(nil)

type fastReflection_MsgBurnNft MsgBurnNft

func (x *MsgBurnNft) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgBurnNft)(x)
}

func (x *MsgBurnNft) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgBurnNft_messageType fastReflection_MsgBurnNft_messageType
var _ protoreflect.MessageType = fastReflection_MsgBurnNft_messageType{}

type fastReflection_MsgBurnNft_messageType struct{}

func (x fastReflection_MsgBurnNft_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgBurnNft)(nil)
}
func (x fastReflection_MsgBurnNft_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNft)
}
func (x fastReflection_MsgBurnNft_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNft
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgBurnNft) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNft
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgBurnNft) Type() protoreflect.MessageType {
	return _fastReflection_MsgBurnNft_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgBurnNft) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNft)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgBurnNft) Interface() protoreflect.ProtoMessage {
	return (*MsgBurnNft)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgBurnNft) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgBurnNft_creator, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgBurnNft_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgBurnNft_collection_id, value) {
			return
		}
	}
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgBurnNft_nft_id, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgBurnNft_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgBurnNft) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNft.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgBurnNft.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgBurnNft.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgBurnNft.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgBurnNft.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNft does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNft) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNft.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgBurnNft.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgBurnNft.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgBurnNft.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgBurnNft.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNft does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgBurnNft) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgBurnNft.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNft.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNft.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNft.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNft.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNft does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNft) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNft.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNft.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNft.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNft.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNft.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNft does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNft) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNft.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgBurnNft is not mutable"))
	case "mantrachain.token.v1.MsgBurnNft.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgBurnNft is not mutable"))
	case "mantrachain.token.v1.MsgBurnNft.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgBurnNft is not mutable"))
	case "mantrachain.token.v1.MsgBurnNft.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgBurnNft is not mutable"))
	case "mantrachain.token.v1.MsgBurnNft.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgBurnNft is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNft does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgBurnNft) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNft.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNft.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNft.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNft.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNft.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNft does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgBurnNft) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgBurnNft", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgBurnNft) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNft) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgBurnNft) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgBurnNft) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgBurnNft)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNft)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNft)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNft: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNft: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgBurnNftResponse                    protoreflect.MessageDescriptor
	fd_MsgBurnNftResponse_nft_id             protoreflect.FieldDescriptor
	fd_MsgBurnNftResponse_burner             protoreflect.FieldDescriptor
	fd_MsgBurnNftResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgBurnNftResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgBurnNftResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgBurnNftResponse")
	fd_MsgBurnNftResponse_nft_id = md_MsgBurnNftResponse.Fields().ByName("nft_id")
	fd_MsgBurnNftResponse_burner = md_MsgBurnNftResponse.Fields().ByName("burner")
	fd_MsgBurnNftResponse_collection_creator = md_MsgBurnNftResponse.Fields().ByName("collection_creator")
	fd_MsgBurnNftResponse_collection_id = md_MsgBurnNftResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgBurnNftResponse)(nil)

type fastReflection_MsgBurnNftResponse MsgBurnNftResponse

func (x *MsgBurnNftResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgBurnNftResponse)(x)
}

func (x *MsgBurnNftResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgBurnNftResponse_messageType fastReflection_MsgBurnNftResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgBurnNftResponse_messageType{}

type fastReflection_MsgBurnNftResponse_messageType struct{}

func (x fastReflection_MsgBurnNftResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgBurnNftResponse)(nil)
}
func (x fastReflection_MsgBurnNftResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNftResponse)
}
func (x fastReflection_MsgBurnNftResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNftResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgBurnNftResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNftResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgBurnNftResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgBurnNftResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgBurnNftResponse) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNftResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgBurnNftResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgBurnNftResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgBurnNftResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgBurnNftResponse_nft_id, value) {
			return
		}
	}
	if x.Burner != "" {
		value := protoreflect.ValueOfString(x.Burner)
		if !f(fd_MsgBurnNftResponse_burner, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgBurnNftResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgBurnNftResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgBurnNftResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftResponse.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgBurnNftResponse.burner":
		return x.Burner != ""
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftResponse.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgBurnNftResponse.burner":
		x.Burner = ""
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgBurnNftResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgBurnNftResponse.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNftResponse.burner":
		value := x.Burner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftResponse.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNftResponse.burner":
		x.Burner = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftResponse.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgBurnNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgBurnNftResponse.burner":
		panic(fmt.Errorf("field burner of message mantrachain.token.v1.MsgBurnNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgBurnNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgBurnNftResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgBurnNftResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftResponse.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNftResponse.burner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNftResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgBurnNftResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgBurnNftResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgBurnNftResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgBurnNftResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgBurnNftResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgBurnNftResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Burner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNftResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Burner) > 0 {
			i -= len(x.Burner)
			copy(dAtA[i:], x.Burner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Burner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNftResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNftResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Burner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Burner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgMintNft                    protoreflect.MessageDescriptor
	fd_MsgMintNft_creator            protoreflect.FieldDescriptor
	fd_MsgMintNft_receiver           protoreflect.FieldDescriptor
	fd_MsgMintNft_collection_creator protoreflect.FieldDescriptor
	fd_MsgMintNft_collection_id      protoreflect.FieldDescriptor
	fd_MsgMintNft_nft                protoreflect.FieldDescriptor
	fd_MsgMintNft_strict             protoreflect.FieldDescriptor
	fd_MsgMintNft_did                protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgMintNft = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgMintNft")
	fd_MsgMintNft_creator = md_MsgMintNft.Fields().ByName("creator")
	fd_MsgMintNft_receiver = md_MsgMintNft.Fields().ByName("receiver")
	fd_MsgMintNft_collection_creator = md_MsgMintNft.Fields().ByName("collection_creator")
	fd_MsgMintNft_collection_id = md_MsgMintNft.Fields().ByName("collection_id")
	fd_MsgMintNft_nft = md_MsgMintNft.Fields().ByName("nft")
	fd_MsgMintNft_strict = md_MsgMintNft.Fields().ByName("strict")
	fd_MsgMintNft_did = md_MsgMintNft.Fields().ByName("did")
}

var _ protoreflect.Message = (*fastReflection_MsgMintNft)(nil)

type fastReflection_MsgMintNft MsgMintNft

func (x *MsgMintNft) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgMintNft)(x)
}

func (x *MsgMintNft) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgMintNft_messageType fastReflection_MsgMintNft_messageType
var _ protoreflect.MessageType = fastReflection_MsgMintNft_messageType{}

type fastReflection_MsgMintNft_messageType struct{}

func (x fastReflection_MsgMintNft_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgMintNft)(nil)
}
func (x fastReflection_MsgMintNft_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgMintNft)
}
func (x fastReflection_MsgMintNft_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNft
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgMintNft) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNft
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgMintNft) Type() protoreflect.MessageType {
	return _fastReflection_MsgMintNft_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgMintNft) New() protoreflect.Message {
	return new(fastReflection_MsgMintNft)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgMintNft) Interface() protoreflect.ProtoMessage {
	return (*MsgMintNft)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgMintNft) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgMintNft_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgMintNft_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgMintNft_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgMintNft_collection_id, value) {
			return
		}
	}
	if x.Nft != nil {
		value := protoreflect.ValueOfMessage(x.Nft.ProtoReflect())
		if !f(fd_MsgMintNft_nft, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgMintNft_strict, value) {
			return
		}
	}
	if x.Did != false {
		value := protoreflect.ValueOfBool(x.Did)
		if !f(fd_MsgMintNft_did, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgMintNft) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNft.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgMintNft.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgMintNft.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgMintNft.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgMintNft.nft":
		return x.Nft != nil
	case "mantrachain.token.v1.MsgMintNft.strict":
		return x.Strict != false
	case "mantrachain.token.v1.MsgMintNft.did":
		return x.Did != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNft does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNft) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNft.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgMintNft.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgMintNft.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgMintNft.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgMintNft.nft":
		x.Nft = nil
	case "mantrachain.token.v1.MsgMintNft.strict":
		x.Strict = false
	case "mantrachain.token.v1.MsgMintNft.did":
		x.Did = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNft does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgMintNft) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgMintNft.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNft.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNft.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNft.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNft.nft":
		value := x.Nft
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "mantrachain.token.v1.MsgMintNft.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgMintNft.did":
		value := x.Did
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNft does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNft) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNft.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNft.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNft.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNft.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNft.nft":
		x.Nft = value.Message().Interface().(*MsgNftMetadata)
	case "mantrachain.token.v1.MsgMintNft.strict":
		x.Strict = value.Bool()
	case "mantrachain.token.v1.MsgMintNft.did":
		x.Did = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNft does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNft) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNft.nft":
		if x.Nft == nil {
			x.Nft = new(MsgNftMetadata)
		}
		return protoreflect.ValueOfMessage(x.Nft.ProtoReflect())
	case "mantrachain.token.v1.MsgMintNft.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgMintNft is not mutable"))
	case "mantrachain.token.v1.MsgMintNft.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgMintNft is not mutable"))
	case "mantrachain.token.v1.MsgMintNft.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgMintNft is not mutable"))
	case "mantrachain.token.v1.MsgMintNft.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgMintNft is not mutable"))
	case "mantrachain.token.v1.MsgMintNft.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgMintNft is not mutable"))
	case "mantrachain.token.v1.MsgMintNft.did":
		panic(fmt.Errorf("field did of message mantrachain.token.v1.MsgMintNft is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNft does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgMintNft) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNft.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNft.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNft.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNft.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNft.nft":
		m := new(MsgNftMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "mantrachain.token.v1.MsgMintNft.strict":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgMintNft.did":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNft"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNft does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgMintNft) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgMintNft", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgMintNft) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNft) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgMintNft) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgMintNft) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgMintNft)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Nft != nil {
			l = options.Size(x.Nft)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Strict {
			n += 2
		}
		if x.Did {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNft)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Did {
			i--
			if x.Did {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.Nft != nil {
			encoded, err := options.Marshal(x.Nft)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNft)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNft: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNft: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nft", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Nft == nil {
					x.Nft = &MsgNftMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Nft); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Did = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgMintNftResponse                    protoreflect.MessageDescriptor
	fd_MsgMintNftResponse_nft_id             protoreflect.FieldDescriptor
	fd_MsgMintNftResponse_creator            protoreflect.FieldDescriptor
	fd_MsgMintNftResponse_receiver           protoreflect.FieldDescriptor
	fd_MsgMintNftResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgMintNftResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgMintNftResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgMintNftResponse")
	fd_MsgMintNftResponse_nft_id = md_MsgMintNftResponse.Fields().ByName("nft_id")
	fd_MsgMintNftResponse_creator = md_MsgMintNftResponse.Fields().ByName("creator")
	fd_MsgMintNftResponse_receiver = md_MsgMintNftResponse.Fields().ByName("receiver")
	fd_MsgMintNftResponse_collection_creator = md_MsgMintNftResponse.Fields().ByName("collection_creator")
	fd_MsgMintNftResponse_collection_id = md_MsgMintNftResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgMintNftResponse)(nil)

type fastReflection_MsgMintNftResponse MsgMintNftResponse

func (x *MsgMintNftResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgMintNftResponse)(x)
}

func (x *MsgMintNftResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgMintNftResponse_messageType fastReflection_MsgMintNftResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgMintNftResponse_messageType{}

type fastReflection_MsgMintNftResponse_messageType struct{}

func (x fastReflection_MsgMintNftResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgMintNftResponse)(nil)
}
func (x fastReflection_MsgMintNftResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgMintNftResponse)
}
func (x fastReflection_MsgMintNftResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNftResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgMintNftResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNftResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgMintNftResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgMintNftResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgMintNftResponse) New() protoreflect.Message {
	return new(fastReflection_MsgMintNftResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgMintNftResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgMintNftResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgMintNftResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NftId != "" {
		value := protoreflect.ValueOfString(x.NftId)
		if !f(fd_MsgMintNftResponse_nft_id, value) {
			return
		}
	}
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgMintNftResponse_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgMintNftResponse_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgMintNftResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgMintNftResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgMintNftResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftResponse.nft_id":
		return x.NftId != ""
	case "mantrachain.token.v1.MsgMintNftResponse.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgMintNftResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgMintNftResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgMintNftResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftResponse.nft_id":
		x.NftId = ""
	case "mantrachain.token.v1.MsgMintNftResponse.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgMintNftResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgMintNftResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgMintNftResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgMintNftResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgMintNftResponse.nft_id":
		value := x.NftId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftResponse.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftResponse.nft_id":
		x.NftId = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftResponse.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftResponse.nft_id":
		panic(fmt.Errorf("field nft_id of message mantrachain.token.v1.MsgMintNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftResponse.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgMintNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgMintNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgMintNftResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgMintNftResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgMintNftResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftResponse.nft_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftResponse.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgMintNftResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgMintNftResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgMintNftResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgMintNftResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgMintNftResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgMintNftResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.NftId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNftResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.NftId) > 0 {
			i -= len(x.NftId)
			copy(dAtA[i:], x.NftId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNftResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNftResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNftResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgApproveAllNfts          protoreflect.MessageDescriptor
	fd_MsgApproveAllNfts_creator  protoreflect.FieldDescriptor
	fd_MsgApproveAllNfts_receiver protoreflect.FieldDescriptor
	fd_MsgApproveAllNfts_approved protoreflect.FieldDescriptor
	fd_MsgApproveAllNfts_strict   protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgApproveAllNfts = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgApproveAllNfts")
	fd_MsgApproveAllNfts_creator = md_MsgApproveAllNfts.Fields().ByName("creator")
	fd_MsgApproveAllNfts_receiver = md_MsgApproveAllNfts.Fields().ByName("receiver")
	fd_MsgApproveAllNfts_approved = md_MsgApproveAllNfts.Fields().ByName("approved")
	fd_MsgApproveAllNfts_strict = md_MsgApproveAllNfts.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgApproveAllNfts)(nil)

type fastReflection_MsgApproveAllNfts MsgApproveAllNfts

func (x *MsgApproveAllNfts) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgApproveAllNfts)(x)
}

func (x *MsgApproveAllNfts) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgApproveAllNfts_messageType fastReflection_MsgApproveAllNfts_messageType
var _ protoreflect.MessageType = fastReflection_MsgApproveAllNfts_messageType{}

type fastReflection_MsgApproveAllNfts_messageType struct{}

func (x fastReflection_MsgApproveAllNfts_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgApproveAllNfts)(nil)
}
func (x fastReflection_MsgApproveAllNfts_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgApproveAllNfts)
}
func (x fastReflection_MsgApproveAllNfts_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveAllNfts
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgApproveAllNfts) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveAllNfts
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgApproveAllNfts) Type() protoreflect.MessageType {
	return _fastReflection_MsgApproveAllNfts_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgApproveAllNfts) New() protoreflect.Message {
	return new(fastReflection_MsgApproveAllNfts)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgApproveAllNfts) Interface() protoreflect.ProtoMessage {
	return (*MsgApproveAllNfts)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgApproveAllNfts) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgApproveAllNfts_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgApproveAllNfts_receiver, value) {
			return
		}
	}
	if x.Approved != false {
		value := protoreflect.ValueOfBool(x.Approved)
		if !f(fd_MsgApproveAllNfts_approved, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgApproveAllNfts_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgApproveAllNfts) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNfts.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgApproveAllNfts.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgApproveAllNfts.approved":
		return x.Approved != false
	case "mantrachain.token.v1.MsgApproveAllNfts.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNfts does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNfts) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNfts.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgApproveAllNfts.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgApproveAllNfts.approved":
		x.Approved = false
	case "mantrachain.token.v1.MsgApproveAllNfts.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNfts does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgApproveAllNfts) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNfts.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveAllNfts.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveAllNfts.approved":
		value := x.Approved
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgApproveAllNfts.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNfts does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNfts) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNfts.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveAllNfts.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveAllNfts.approved":
		x.Approved = value.Bool()
	case "mantrachain.token.v1.MsgApproveAllNfts.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNfts does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNfts) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNfts.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgApproveAllNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveAllNfts.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgApproveAllNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveAllNfts.approved":
		panic(fmt.Errorf("field approved of message mantrachain.token.v1.MsgApproveAllNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveAllNfts.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgApproveAllNfts is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNfts does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgApproveAllNfts) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNfts.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveAllNfts.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveAllNfts.approved":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgApproveAllNfts.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNfts does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgApproveAllNfts) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgApproveAllNfts", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgApproveAllNfts) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNfts) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgApproveAllNfts) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgApproveAllNfts) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgApproveAllNfts)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Approved {
			n += 2
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveAllNfts)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x20
		}
		if x.Approved {
			i--
			if x.Approved {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveAllNfts)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveAllNfts: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveAllNfts: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Approved = bool(v != 0)
			case 4:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgApproveAllNftsResponse          protoreflect.MessageDescriptor
	fd_MsgApproveAllNftsResponse_owner    protoreflect.FieldDescriptor
	fd_MsgApproveAllNftsResponse_receiver protoreflect.FieldDescriptor
	fd_MsgApproveAllNftsResponse_approved protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgApproveAllNftsResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgApproveAllNftsResponse")
	fd_MsgApproveAllNftsResponse_owner = md_MsgApproveAllNftsResponse.Fields().ByName("owner")
	fd_MsgApproveAllNftsResponse_receiver = md_MsgApproveAllNftsResponse.Fields().ByName("receiver")
	fd_MsgApproveAllNftsResponse_approved = md_MsgApproveAllNftsResponse.Fields().ByName("approved")
}

var _ protoreflect.Message = (*fastReflection_MsgApproveAllNftsResponse)(nil)

type fastReflection_MsgApproveAllNftsResponse MsgApproveAllNftsResponse

func (x *MsgApproveAllNftsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgApproveAllNftsResponse)(x)
}

func (x *MsgApproveAllNftsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgApproveAllNftsResponse_messageType fastReflection_MsgApproveAllNftsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgApproveAllNftsResponse_messageType{}

type fastReflection_MsgApproveAllNftsResponse_messageType struct{}

func (x fastReflection_MsgApproveAllNftsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgApproveAllNftsResponse)(nil)
}
func (x fastReflection_MsgApproveAllNftsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgApproveAllNftsResponse)
}
func (x fastReflection_MsgApproveAllNftsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveAllNftsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgApproveAllNftsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveAllNftsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgApproveAllNftsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgApproveAllNftsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgApproveAllNftsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgApproveAllNftsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgApproveAllNftsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgApproveAllNftsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgApproveAllNftsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgApproveAllNftsResponse_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgApproveAllNftsResponse_receiver, value) {
			return
		}
	}
	if x.Approved != false {
		value := protoreflect.ValueOfBool(x.Approved)
		if !f(fd_MsgApproveAllNftsResponse_approved, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgApproveAllNftsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.approved":
		return x.Approved != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNftsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.approved":
		x.Approved = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgApproveAllNftsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.approved":
		value := x.Approved
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNftsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNftsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.approved":
		x.Approved = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNftsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgApproveAllNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgApproveAllNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.approved":
		panic(fmt.Errorf("field approved of message mantrachain.token.v1.MsgApproveAllNftsResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNftsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgApproveAllNftsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveAllNftsResponse.approved":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveAllNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveAllNftsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgApproveAllNftsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgApproveAllNftsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgApproveAllNftsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveAllNftsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgApproveAllNftsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgApproveAllNftsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgApproveAllNftsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Approved {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveAllNftsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Approved {
			i--
			if x.Approved {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x18
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveAllNftsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveAllNftsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveAllNftsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Approved = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgApproveNfts                    protoreflect.MessageDescriptor
	fd_MsgApproveNfts_creator            protoreflect.FieldDescriptor
	fd_MsgApproveNfts_receiver           protoreflect.FieldDescriptor
	fd_MsgApproveNfts_collection_creator protoreflect.FieldDescriptor
	fd_MsgApproveNfts_collection_id      protoreflect.FieldDescriptor
	fd_MsgApproveNfts_nfts               protoreflect.FieldDescriptor
	fd_MsgApproveNfts_approved           protoreflect.FieldDescriptor
	fd_MsgApproveNfts_strict             protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgApproveNfts = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgApproveNfts")
	fd_MsgApproveNfts_creator = md_MsgApproveNfts.Fields().ByName("creator")
	fd_MsgApproveNfts_receiver = md_MsgApproveNfts.Fields().ByName("receiver")
	fd_MsgApproveNfts_collection_creator = md_MsgApproveNfts.Fields().ByName("collection_creator")
	fd_MsgApproveNfts_collection_id = md_MsgApproveNfts.Fields().ByName("collection_id")
	fd_MsgApproveNfts_nfts = md_MsgApproveNfts.Fields().ByName("nfts")
	fd_MsgApproveNfts_approved = md_MsgApproveNfts.Fields().ByName("approved")
	fd_MsgApproveNfts_strict = md_MsgApproveNfts.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgApproveNfts)(nil)

type fastReflection_MsgApproveNfts MsgApproveNfts

func (x *MsgApproveNfts) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgApproveNfts)(x)
}

func (x *MsgApproveNfts) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgApproveNfts_messageType fastReflection_MsgApproveNfts_messageType
var _ protoreflect.MessageType = fastReflection_MsgApproveNfts_messageType{}

type fastReflection_MsgApproveNfts_messageType struct{}

func (x fastReflection_MsgApproveNfts_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgApproveNfts)(nil)
}
func (x fastReflection_MsgApproveNfts_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNfts)
}
func (x fastReflection_MsgApproveNfts_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNfts
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgApproveNfts) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNfts
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgApproveNfts) Type() protoreflect.MessageType {
	return _fastReflection_MsgApproveNfts_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgApproveNfts) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNfts)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgApproveNfts) Interface() protoreflect.ProtoMessage {
	return (*MsgApproveNfts)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgApproveNfts) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgApproveNfts_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgApproveNfts_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgApproveNfts_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgApproveNfts_collection_id, value) {
			return
		}
	}
	if x.Nfts != nil {
		value := protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
		if !f(fd_MsgApproveNfts_nfts, value) {
			return
		}
	}
	if x.Approved != false {
		value := protoreflect.ValueOfBool(x.Approved)
		if !f(fd_MsgApproveNfts_approved, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgApproveNfts_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgApproveNfts) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNfts.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgApproveNfts.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgApproveNfts.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgApproveNfts.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgApproveNfts.nfts":
		return x.Nfts != nil
	case "mantrachain.token.v1.MsgApproveNfts.approved":
		return x.Approved != false
	case "mantrachain.token.v1.MsgApproveNfts.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNfts does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNfts) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNfts.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgApproveNfts.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgApproveNfts.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgApproveNfts.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgApproveNfts.nfts":
		x.Nfts = nil
	case "mantrachain.token.v1.MsgApproveNfts.approved":
		x.Approved = false
	case "mantrachain.token.v1.MsgApproveNfts.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNfts does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgApproveNfts) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgApproveNfts.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNfts.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNfts.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNfts.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNfts.nfts":
		value := x.Nfts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "mantrachain.token.v1.MsgApproveNfts.approved":
		value := x.Approved
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgApproveNfts.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNfts does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNfts) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNfts.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNfts.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNfts.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNfts.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNfts.nfts":
		x.Nfts = value.Message().Interface().(*MsgNftsIds)
	case "mantrachain.token.v1.MsgApproveNfts.approved":
		x.Approved = value.Bool()
	case "mantrachain.token.v1.MsgApproveNfts.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNfts does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNfts) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNfts.nfts":
		if x.Nfts == nil {
			x.Nfts = new(MsgNftsIds)
		}
		return protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
	case "mantrachain.token.v1.MsgApproveNfts.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgApproveNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveNfts.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgApproveNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveNfts.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgApproveNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveNfts.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgApproveNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveNfts.approved":
		panic(fmt.Errorf("field approved of message mantrachain.token.v1.MsgApproveNfts is not mutable"))
	case "mantrachain.token.v1.MsgApproveNfts.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgApproveNfts is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNfts does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgApproveNfts) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNfts.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNfts.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNfts.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNfts.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNfts.nfts":
		m := new(MsgNftsIds)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "mantrachain.token.v1.MsgApproveNfts.approved":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgApproveNfts.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNfts does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgApproveNfts) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgApproveNfts", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgApproveNfts) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNfts) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgApproveNfts) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgApproveNfts) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgApproveNfts)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Nfts != nil {
			l = options.Size(x.Nfts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Approved {
			n += 2
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNfts)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if x.Approved {
			i--
			if x.Approved {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.Nfts != nil {
			encoded, err := options.Marshal(x.Nfts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNfts)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNfts: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNfts: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nfts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Nfts == nil {
					x.Nfts = &MsgNftsIds{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Nfts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Approved = bool(v != 0)
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgApproveNftsResponse_1_list)(nil)

type _MsgApproveNftsResponse_1_list struct {
	list *[]string
}

func (x *_MsgApproveNftsResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgApproveNftsResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_MsgApproveNftsResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgApproveNftsResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgApproveNftsResponse_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgApproveNftsResponse at list field NftsIds as it is not of Message kind"))
}

func (x *_MsgApproveNftsResponse_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgApproveNftsResponse_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_MsgApproveNftsResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgApproveNftsResponse                    protoreflect.MessageDescriptor
	fd_MsgApproveNftsResponse_nfts_ids           protoreflect.FieldDescriptor
	fd_MsgApproveNftsResponse_nfts_count         protoreflect.FieldDescriptor
	fd_MsgApproveNftsResponse_owner              protoreflect.FieldDescriptor
	fd_MsgApproveNftsResponse_receiver           protoreflect.FieldDescriptor
	fd_MsgApproveNftsResponse_approved           protoreflect.FieldDescriptor
	fd_MsgApproveNftsResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgApproveNftsResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgApproveNftsResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgApproveNftsResponse")
	fd_MsgApproveNftsResponse_nfts_ids = md_MsgApproveNftsResponse.Fields().ByName("nfts_ids")
	fd_MsgApproveNftsResponse_nfts_count = md_MsgApproveNftsResponse.Fields().ByName("nfts_count")
	fd_MsgApproveNftsResponse_owner = md_MsgApproveNftsResponse.Fields().ByName("owner")
	fd_MsgApproveNftsResponse_receiver = md_MsgApproveNftsResponse.Fields().ByName("receiver")
	fd_MsgApproveNftsResponse_approved = md_MsgApproveNftsResponse.Fields().ByName("approved")
	fd_MsgApproveNftsResponse_collection_creator = md_MsgApproveNftsResponse.Fields().ByName("collection_creator")
	fd_MsgApproveNftsResponse_collection_id = md_MsgApproveNftsResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgApproveNftsResponse)(nil)

type fastReflection_MsgApproveNftsResponse MsgApproveNftsResponse

func (x *MsgApproveNftsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgApproveNftsResponse)(x)
}

func (x *MsgApproveNftsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgApproveNftsResponse_messageType fastReflection_MsgApproveNftsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgApproveNftsResponse_messageType{}

type fastReflection_MsgApproveNftsResponse_messageType struct{}

func (x fastReflection_MsgApproveNftsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgApproveNftsResponse)(nil)
}
func (x fastReflection_MsgApproveNftsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNftsResponse)
}
func (x fastReflection_MsgApproveNftsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNftsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgApproveNftsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgApproveNftsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgApproveNftsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgApproveNftsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgApproveNftsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgApproveNftsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgApproveNftsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgApproveNftsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgApproveNftsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NftsIds) != 0 {
		value := protoreflect.ValueOfList(&_MsgApproveNftsResponse_1_list{list: &x.NftsIds})
		if !f(fd_MsgApproveNftsResponse_nfts_ids, value) {
			return
		}
	}
	if x.NftsCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.NftsCount)
		if !f(fd_MsgApproveNftsResponse_nfts_count, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgApproveNftsResponse_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgApproveNftsResponse_receiver, value) {
			return
		}
	}
	if x.Approved != false {
		value := protoreflect.ValueOfBool(x.Approved)
		if !f(fd_MsgApproveNftsResponse_approved, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgApproveNftsResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgApproveNftsResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgApproveNftsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_ids":
		return len(x.NftsIds) != 0
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_count":
		return x.NftsCount != uint32(0)
	case "mantrachain.token.v1.MsgApproveNftsResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgApproveNftsResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgApproveNftsResponse.approved":
		return x.Approved != false
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_ids":
		x.NftsIds = nil
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_count":
		x.NftsCount = uint32(0)
	case "mantrachain.token.v1.MsgApproveNftsResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgApproveNftsResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgApproveNftsResponse.approved":
		x.Approved = false
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgApproveNftsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_ids":
		if len(x.NftsIds) == 0 {
			return protoreflect.ValueOfList(&_MsgApproveNftsResponse_1_list{})
		}
		listValue := &_MsgApproveNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(listValue)
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_count":
		value := x.NftsCount
		return protoreflect.ValueOfUint32(value)
	case "mantrachain.token.v1.MsgApproveNftsResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftsResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftsResponse.approved":
		value := x.Approved
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_ids":
		lv := value.List()
		clv := lv.(*_MsgApproveNftsResponse_1_list)
		x.NftsIds = *clv.list
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_count":
		x.NftsCount = uint32(value.Uint())
	case "mantrachain.token.v1.MsgApproveNftsResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftsResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftsResponse.approved":
		x.Approved = value.Bool()
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_ids":
		if x.NftsIds == nil {
			x.NftsIds = []string{}
		}
		value := &_MsgApproveNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(value)
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_count":
		panic(fmt.Errorf("field nfts_count of message mantrachain.token.v1.MsgApproveNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftsResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgApproveNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftsResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgApproveNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftsResponse.approved":
		panic(fmt.Errorf("field approved of message mantrachain.token.v1.MsgApproveNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgApproveNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgApproveNftsResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgApproveNftsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_ids":
		list := []string{}
		return protoreflect.ValueOfList(&_MsgApproveNftsResponse_1_list{list: &list})
	case "mantrachain.token.v1.MsgApproveNftsResponse.nfts_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "mantrachain.token.v1.MsgApproveNftsResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftsResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftsResponse.approved":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgApproveNftsResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgApproveNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgApproveNftsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgApproveNftsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgApproveNftsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgApproveNftsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgApproveNftsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgApproveNftsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgApproveNftsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgApproveNftsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.NftsIds) > 0 {
			for _, s := range x.NftsIds {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NftsCount != 0 {
			n += 1 + runtime.Sov(uint64(x.NftsCount))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Approved {
			n += 2
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNftsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x32
		}
		if x.Approved {
			i--
			if x.Approved {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NftsCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NftsCount))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NftsIds) > 0 {
			for iNdEx := len(x.NftsIds) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.NftsIds[iNdEx])
				copy(dAtA[i:], x.NftsIds[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftsIds[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgApproveNftsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNftsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgApproveNftsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsIds", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftsIds = append(x.NftsIds, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsCount", wireType)
				}
				x.NftsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NftsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Approved", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Approved = bool(v != 0)
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgTransferNfts                    protoreflect.MessageDescriptor
	fd_MsgTransferNfts_creator            protoreflect.FieldDescriptor
	fd_MsgTransferNfts_owner              protoreflect.FieldDescriptor
	fd_MsgTransferNfts_receiver           protoreflect.FieldDescriptor
	fd_MsgTransferNfts_collection_creator protoreflect.FieldDescriptor
	fd_MsgTransferNfts_collection_id      protoreflect.FieldDescriptor
	fd_MsgTransferNfts_nfts               protoreflect.FieldDescriptor
	fd_MsgTransferNfts_strict             protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgTransferNfts = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgTransferNfts")
	fd_MsgTransferNfts_creator = md_MsgTransferNfts.Fields().ByName("creator")
	fd_MsgTransferNfts_owner = md_MsgTransferNfts.Fields().ByName("owner")
	fd_MsgTransferNfts_receiver = md_MsgTransferNfts.Fields().ByName("receiver")
	fd_MsgTransferNfts_collection_creator = md_MsgTransferNfts.Fields().ByName("collection_creator")
	fd_MsgTransferNfts_collection_id = md_MsgTransferNfts.Fields().ByName("collection_id")
	fd_MsgTransferNfts_nfts = md_MsgTransferNfts.Fields().ByName("nfts")
	fd_MsgTransferNfts_strict = md_MsgTransferNfts.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgTransferNfts)(nil)

type fastReflection_MsgTransferNfts MsgTransferNfts

func (x *MsgTransferNfts) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgTransferNfts)(x)
}

func (x *MsgTransferNfts) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgTransferNfts_messageType fastReflection_MsgTransferNfts_messageType
var _ protoreflect.MessageType = fastReflection_MsgTransferNfts_messageType{}

type fastReflection_MsgTransferNfts_messageType struct{}

func (x fastReflection_MsgTransferNfts_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgTransferNfts)(nil)
}
func (x fastReflection_MsgTransferNfts_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNfts)
}
func (x fastReflection_MsgTransferNfts_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNfts
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgTransferNfts) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNfts
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgTransferNfts) Type() protoreflect.MessageType {
	return _fastReflection_MsgTransferNfts_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgTransferNfts) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNfts)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgTransferNfts) Interface() protoreflect.ProtoMessage {
	return (*MsgTransferNfts)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgTransferNfts) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgTransferNfts_creator, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgTransferNfts_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgTransferNfts_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgTransferNfts_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgTransferNfts_collection_id, value) {
			return
		}
	}
	if x.Nfts != nil {
		value := protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
		if !f(fd_MsgTransferNfts_nfts, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgTransferNfts_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgTransferNfts) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNfts.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgTransferNfts.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgTransferNfts.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgTransferNfts.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgTransferNfts.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgTransferNfts.nfts":
		return x.Nfts != nil
	case "mantrachain.token.v1.MsgTransferNfts.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNfts does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNfts) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNfts.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgTransferNfts.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgTransferNfts.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgTransferNfts.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgTransferNfts.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgTransferNfts.nfts":
		x.Nfts = nil
	case "mantrachain.token.v1.MsgTransferNfts.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNfts does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgTransferNfts) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgTransferNfts.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNfts.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNfts.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNfts.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNfts.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNfts.nfts":
		value := x.Nfts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "mantrachain.token.v1.MsgTransferNfts.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNfts does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNfts) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNfts.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNfts.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNfts.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNfts.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNfts.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNfts.nfts":
		x.Nfts = value.Message().Interface().(*MsgNftsIds)
	case "mantrachain.token.v1.MsgTransferNfts.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNfts does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNfts) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNfts.nfts":
		if x.Nfts == nil {
			x.Nfts = new(MsgNftsIds)
		}
		return protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
	case "mantrachain.token.v1.MsgTransferNfts.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgTransferNfts is not mutable"))
	case "mantrachain.token.v1.MsgTransferNfts.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgTransferNfts is not mutable"))
	case "mantrachain.token.v1.MsgTransferNfts.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgTransferNfts is not mutable"))
	case "mantrachain.token.v1.MsgTransferNfts.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgTransferNfts is not mutable"))
	case "mantrachain.token.v1.MsgTransferNfts.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgTransferNfts is not mutable"))
	case "mantrachain.token.v1.MsgTransferNfts.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgTransferNfts is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNfts does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgTransferNfts) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNfts.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNfts.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNfts.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNfts.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNfts.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNfts.nfts":
		m := new(MsgNftsIds)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "mantrachain.token.v1.MsgTransferNfts.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNfts does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgTransferNfts) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgTransferNfts", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgTransferNfts) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNfts) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgTransferNfts) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgTransferNfts) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgTransferNfts)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Nfts != nil {
			l = options.Size(x.Nfts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNfts)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if x.Nfts != nil {
			encoded, err := options.Marshal(x.Nfts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNfts)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNfts: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNfts: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nfts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Nfts == nil {
					x.Nfts = &MsgNftsIds{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Nfts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgTransferNftsResponse_1_list)(nil)

type _MsgTransferNftsResponse_1_list struct {
	list *[]string
}

func (x *_MsgTransferNftsResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgTransferNftsResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_MsgTransferNftsResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgTransferNftsResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgTransferNftsResponse_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgTransferNftsResponse at list field NftsIds as it is not of Message kind"))
}

func (x *_MsgTransferNftsResponse_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgTransferNftsResponse_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_MsgTransferNftsResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgTransferNftsResponse                    protoreflect.MessageDescriptor
	fd_MsgTransferNftsResponse_nfts_ids           protoreflect.FieldDescriptor
	fd_MsgTransferNftsResponse_nfts_count         protoreflect.FieldDescriptor
	fd_MsgTransferNftsResponse_operator           protoreflect.FieldDescriptor
	fd_MsgTransferNftsResponse_owner              protoreflect.FieldDescriptor
	fd_MsgTransferNftsResponse_receiver           protoreflect.FieldDescriptor
	fd_MsgTransferNftsResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgTransferNftsResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgTransferNftsResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgTransferNftsResponse")
	fd_MsgTransferNftsResponse_nfts_ids = md_MsgTransferNftsResponse.Fields().ByName("nfts_ids")
	fd_MsgTransferNftsResponse_nfts_count = md_MsgTransferNftsResponse.Fields().ByName("nfts_count")
	fd_MsgTransferNftsResponse_operator = md_MsgTransferNftsResponse.Fields().ByName("operator")
	fd_MsgTransferNftsResponse_owner = md_MsgTransferNftsResponse.Fields().ByName("owner")
	fd_MsgTransferNftsResponse_receiver = md_MsgTransferNftsResponse.Fields().ByName("receiver")
	fd_MsgTransferNftsResponse_collection_creator = md_MsgTransferNftsResponse.Fields().ByName("collection_creator")
	fd_MsgTransferNftsResponse_collection_id = md_MsgTransferNftsResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgTransferNftsResponse)(nil)

type fastReflection_MsgTransferNftsResponse MsgTransferNftsResponse

func (x *MsgTransferNftsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgTransferNftsResponse)(x)
}

func (x *MsgTransferNftsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgTransferNftsResponse_messageType fastReflection_MsgTransferNftsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgTransferNftsResponse_messageType{}

type fastReflection_MsgTransferNftsResponse_messageType struct{}

func (x fastReflection_MsgTransferNftsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgTransferNftsResponse)(nil)
}
func (x fastReflection_MsgTransferNftsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNftsResponse)
}
func (x fastReflection_MsgTransferNftsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNftsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgTransferNftsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgTransferNftsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgTransferNftsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgTransferNftsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgTransferNftsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgTransferNftsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgTransferNftsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgTransferNftsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgTransferNftsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NftsIds) != 0 {
		value := protoreflect.ValueOfList(&_MsgTransferNftsResponse_1_list{list: &x.NftsIds})
		if !f(fd_MsgTransferNftsResponse_nfts_ids, value) {
			return
		}
	}
	if x.NftsCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.NftsCount)
		if !f(fd_MsgTransferNftsResponse_nfts_count, value) {
			return
		}
	}
	if x.Operator != "" {
		value := protoreflect.ValueOfString(x.Operator)
		if !f(fd_MsgTransferNftsResponse_operator, value) {
			return
		}
	}
	if x.Owner != "" {
		value := protoreflect.ValueOfString(x.Owner)
		if !f(fd_MsgTransferNftsResponse_owner, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgTransferNftsResponse_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgTransferNftsResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgTransferNftsResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgTransferNftsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_ids":
		return len(x.NftsIds) != 0
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_count":
		return x.NftsCount != uint32(0)
	case "mantrachain.token.v1.MsgTransferNftsResponse.operator":
		return x.Operator != ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.owner":
		return x.Owner != ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_ids":
		x.NftsIds = nil
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_count":
		x.NftsCount = uint32(0)
	case "mantrachain.token.v1.MsgTransferNftsResponse.operator":
		x.Operator = ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.owner":
		x.Owner = ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgTransferNftsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_ids":
		if len(x.NftsIds) == 0 {
			return protoreflect.ValueOfList(&_MsgTransferNftsResponse_1_list{})
		}
		listValue := &_MsgTransferNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(listValue)
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_count":
		value := x.NftsCount
		return protoreflect.ValueOfUint32(value)
	case "mantrachain.token.v1.MsgTransferNftsResponse.operator":
		value := x.Operator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftsResponse.owner":
		value := x.Owner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftsResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_ids":
		lv := value.List()
		clv := lv.(*_MsgTransferNftsResponse_1_list)
		x.NftsIds = *clv.list
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_count":
		x.NftsCount = uint32(value.Uint())
	case "mantrachain.token.v1.MsgTransferNftsResponse.operator":
		x.Operator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftsResponse.owner":
		x.Owner = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftsResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_ids":
		if x.NftsIds == nil {
			x.NftsIds = []string{}
		}
		value := &_MsgTransferNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(value)
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_count":
		panic(fmt.Errorf("field nfts_count of message mantrachain.token.v1.MsgTransferNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftsResponse.operator":
		panic(fmt.Errorf("field operator of message mantrachain.token.v1.MsgTransferNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftsResponse.owner":
		panic(fmt.Errorf("field owner of message mantrachain.token.v1.MsgTransferNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftsResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgTransferNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgTransferNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgTransferNftsResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgTransferNftsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_ids":
		list := []string{}
		return protoreflect.ValueOfList(&_MsgTransferNftsResponse_1_list{list: &list})
	case "mantrachain.token.v1.MsgTransferNftsResponse.nfts_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "mantrachain.token.v1.MsgTransferNftsResponse.operator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftsResponse.owner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftsResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgTransferNftsResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgTransferNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgTransferNftsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgTransferNftsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgTransferNftsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgTransferNftsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgTransferNftsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgTransferNftsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgTransferNftsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgTransferNftsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.NftsIds) > 0 {
			for _, s := range x.NftsIds {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NftsCount != 0 {
			n += 1 + runtime.Sov(uint64(x.NftsCount))
		}
		l = len(x.Operator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Owner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNftsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Owner) > 0 {
			i -= len(x.Owner)
			copy(dAtA[i:], x.Owner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Owner)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Operator) > 0 {
			i -= len(x.Operator)
			copy(dAtA[i:], x.Operator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Operator)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NftsCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NftsCount))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NftsIds) > 0 {
			for iNdEx := len(x.NftsIds) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.NftsIds[iNdEx])
				copy(dAtA[i:], x.NftsIds[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftsIds[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgTransferNftsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNftsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgTransferNftsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsIds", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftsIds = append(x.NftsIds, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsCount", wireType)
				}
				x.NftsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NftsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Operator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Owner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgCreateNftCollection            protoreflect.MessageDescriptor
	fd_MsgCreateNftCollection_creator    protoreflect.FieldDescriptor
	fd_MsgCreateNftCollection_collection protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgCreateNftCollection = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgCreateNftCollection")
	fd_MsgCreateNftCollection_creator = md_MsgCreateNftCollection.Fields().ByName("creator")
	fd_MsgCreateNftCollection_collection = md_MsgCreateNftCollection.Fields().ByName("collection")
}

var _ protoreflect.Message = (*fastReflection_MsgCreateNftCollection)(nil)

type fastReflection_MsgCreateNftCollection MsgCreateNftCollection

func (x *MsgCreateNftCollection) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgCreateNftCollection)(x)
}

func (x *MsgCreateNftCollection) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgCreateNftCollection_messageType fastReflection_MsgCreateNftCollection_messageType
var _ protoreflect.MessageType = fastReflection_MsgCreateNftCollection_messageType{}

type fastReflection_MsgCreateNftCollection_messageType struct{}

func (x fastReflection_MsgCreateNftCollection_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgCreateNftCollection)(nil)
}
func (x fastReflection_MsgCreateNftCollection_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgCreateNftCollection)
}
func (x fastReflection_MsgCreateNftCollection_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateNftCollection
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgCreateNftCollection) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateNftCollection
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgCreateNftCollection) Type() protoreflect.MessageType {
	return _fastReflection_MsgCreateNftCollection_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgCreateNftCollection) New() protoreflect.Message {
	return new(fastReflection_MsgCreateNftCollection)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgCreateNftCollection) Interface() protoreflect.ProtoMessage {
	return (*MsgCreateNftCollection)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgCreateNftCollection) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgCreateNftCollection_creator, value) {
			return
		}
	}
	if x.Collection != nil {
		value := protoreflect.ValueOfMessage(x.Collection.ProtoReflect())
		if !f(fd_MsgCreateNftCollection_collection, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgCreateNftCollection) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollection.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgCreateNftCollection.collection":
		return x.Collection != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollection"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollection does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollection) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollection.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgCreateNftCollection.collection":
		x.Collection = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollection"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollection does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgCreateNftCollection) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollection.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgCreateNftCollection.collection":
		value := x.Collection
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollection"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollection does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollection) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollection.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgCreateNftCollection.collection":
		x.Collection = value.Message().Interface().(*MsgCreateNftCollectionMetadata)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollection"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollection does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollection) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollection.collection":
		if x.Collection == nil {
			x.Collection = new(MsgCreateNftCollectionMetadata)
		}
		return protoreflect.ValueOfMessage(x.Collection.ProtoReflect())
	case "mantrachain.token.v1.MsgCreateNftCollection.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgCreateNftCollection is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollection"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollection does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgCreateNftCollection) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollection.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgCreateNftCollection.collection":
		m := new(MsgCreateNftCollectionMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollection"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollection does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgCreateNftCollection) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgCreateNftCollection", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgCreateNftCollection) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollection) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgCreateNftCollection) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgCreateNftCollection) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgCreateNftCollection)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Collection != nil {
			l = options.Size(x.Collection)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateNftCollection)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Collection != nil {
			encoded, err := options.Marshal(x.Collection)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateNftCollection)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateNftCollection: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateNftCollection: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Collection", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Collection == nil {
					x.Collection = &MsgCreateNftCollectionMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Collection); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgCreateNftCollectionResponse                    protoreflect.MessageDescriptor
	fd_MsgCreateNftCollectionResponse_collection_id      protoreflect.FieldDescriptor
	fd_MsgCreateNftCollectionResponse_collection_creator protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgCreateNftCollectionResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgCreateNftCollectionResponse")
	fd_MsgCreateNftCollectionResponse_collection_id = md_MsgCreateNftCollectionResponse.Fields().ByName("collection_id")
	fd_MsgCreateNftCollectionResponse_collection_creator = md_MsgCreateNftCollectionResponse.Fields().ByName("collection_creator")
}

var _ protoreflect.Message = (*fastReflection_MsgCreateNftCollectionResponse)(nil)

type fastReflection_MsgCreateNftCollectionResponse MsgCreateNftCollectionResponse

func (x *MsgCreateNftCollectionResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgCreateNftCollectionResponse)(x)
}

func (x *MsgCreateNftCollectionResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgCreateNftCollectionResponse_messageType fastReflection_MsgCreateNftCollectionResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgCreateNftCollectionResponse_messageType{}

type fastReflection_MsgCreateNftCollectionResponse_messageType struct{}

func (x fastReflection_MsgCreateNftCollectionResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgCreateNftCollectionResponse)(nil)
}
func (x fastReflection_MsgCreateNftCollectionResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgCreateNftCollectionResponse)
}
func (x fastReflection_MsgCreateNftCollectionResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateNftCollectionResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgCreateNftCollectionResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgCreateNftCollectionResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgCreateNftCollectionResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgCreateNftCollectionResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgCreateNftCollectionResponse) New() protoreflect.Message {
	return new(fastReflection_MsgCreateNftCollectionResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgCreateNftCollectionResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgCreateNftCollectionResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgCreateNftCollectionResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgCreateNftCollectionResponse_collection_id, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgCreateNftCollectionResponse_collection_creator, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgCreateNftCollectionResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_creator":
		return x.CollectionCreator != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollectionResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollectionResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollectionResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_creator":
		x.CollectionCreator = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollectionResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollectionResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgCreateNftCollectionResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollectionResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollectionResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollectionResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollectionResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollectionResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollectionResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgCreateNftCollectionResponse is not mutable"))
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgCreateNftCollectionResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollectionResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollectionResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgCreateNftCollectionResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgCreateNftCollectionResponse.collection_creator":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgCreateNftCollectionResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgCreateNftCollectionResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgCreateNftCollectionResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgCreateNftCollectionResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgCreateNftCollectionResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgCreateNftCollectionResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgCreateNftCollectionResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgCreateNftCollectionResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgCreateNftCollectionResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateNftCollectionResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgCreateNftCollectionResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateNftCollectionResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgCreateNftCollectionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgMintNfts                    protoreflect.MessageDescriptor
	fd_MsgMintNfts_creator            protoreflect.FieldDescriptor
	fd_MsgMintNfts_receiver           protoreflect.FieldDescriptor
	fd_MsgMintNfts_collection_creator protoreflect.FieldDescriptor
	fd_MsgMintNfts_collection_id      protoreflect.FieldDescriptor
	fd_MsgMintNfts_nfts               protoreflect.FieldDescriptor
	fd_MsgMintNfts_strict             protoreflect.FieldDescriptor
	fd_MsgMintNfts_did                protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgMintNfts = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgMintNfts")
	fd_MsgMintNfts_creator = md_MsgMintNfts.Fields().ByName("creator")
	fd_MsgMintNfts_receiver = md_MsgMintNfts.Fields().ByName("receiver")
	fd_MsgMintNfts_collection_creator = md_MsgMintNfts.Fields().ByName("collection_creator")
	fd_MsgMintNfts_collection_id = md_MsgMintNfts.Fields().ByName("collection_id")
	fd_MsgMintNfts_nfts = md_MsgMintNfts.Fields().ByName("nfts")
	fd_MsgMintNfts_strict = md_MsgMintNfts.Fields().ByName("strict")
	fd_MsgMintNfts_did = md_MsgMintNfts.Fields().ByName("did")
}

var _ protoreflect.Message = (*fastReflection_MsgMintNfts)(nil)

type fastReflection_MsgMintNfts MsgMintNfts

func (x *MsgMintNfts) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgMintNfts)(x)
}

func (x *MsgMintNfts) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgMintNfts_messageType fastReflection_MsgMintNfts_messageType
var _ protoreflect.MessageType = fastReflection_MsgMintNfts_messageType{}

type fastReflection_MsgMintNfts_messageType struct{}

func (x fastReflection_MsgMintNfts_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgMintNfts)(nil)
}
func (x fastReflection_MsgMintNfts_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgMintNfts)
}
func (x fastReflection_MsgMintNfts_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNfts
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgMintNfts) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNfts
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgMintNfts) Type() protoreflect.MessageType {
	return _fastReflection_MsgMintNfts_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgMintNfts) New() protoreflect.Message {
	return new(fastReflection_MsgMintNfts)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgMintNfts) Interface() protoreflect.ProtoMessage {
	return (*MsgMintNfts)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgMintNfts) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgMintNfts_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgMintNfts_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgMintNfts_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgMintNfts_collection_id, value) {
			return
		}
	}
	if x.Nfts != nil {
		value := protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
		if !f(fd_MsgMintNfts_nfts, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgMintNfts_strict, value) {
			return
		}
	}
	if x.Did != false {
		value := protoreflect.ValueOfBool(x.Did)
		if !f(fd_MsgMintNfts_did, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgMintNfts) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNfts.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgMintNfts.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgMintNfts.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgMintNfts.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgMintNfts.nfts":
		return x.Nfts != nil
	case "mantrachain.token.v1.MsgMintNfts.strict":
		return x.Strict != false
	case "mantrachain.token.v1.MsgMintNfts.did":
		return x.Did != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNfts does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNfts) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNfts.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgMintNfts.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgMintNfts.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgMintNfts.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgMintNfts.nfts":
		x.Nfts = nil
	case "mantrachain.token.v1.MsgMintNfts.strict":
		x.Strict = false
	case "mantrachain.token.v1.MsgMintNfts.did":
		x.Did = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNfts does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgMintNfts) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgMintNfts.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNfts.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNfts.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNfts.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNfts.nfts":
		value := x.Nfts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "mantrachain.token.v1.MsgMintNfts.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	case "mantrachain.token.v1.MsgMintNfts.did":
		value := x.Did
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNfts does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNfts) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNfts.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNfts.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNfts.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNfts.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNfts.nfts":
		x.Nfts = value.Message().Interface().(*MsgNftsMetadata)
	case "mantrachain.token.v1.MsgMintNfts.strict":
		x.Strict = value.Bool()
	case "mantrachain.token.v1.MsgMintNfts.did":
		x.Did = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNfts does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNfts) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNfts.nfts":
		if x.Nfts == nil {
			x.Nfts = new(MsgNftsMetadata)
		}
		return protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
	case "mantrachain.token.v1.MsgMintNfts.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgMintNfts is not mutable"))
	case "mantrachain.token.v1.MsgMintNfts.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgMintNfts is not mutable"))
	case "mantrachain.token.v1.MsgMintNfts.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgMintNfts is not mutable"))
	case "mantrachain.token.v1.MsgMintNfts.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgMintNfts is not mutable"))
	case "mantrachain.token.v1.MsgMintNfts.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgMintNfts is not mutable"))
	case "mantrachain.token.v1.MsgMintNfts.did":
		panic(fmt.Errorf("field did of message mantrachain.token.v1.MsgMintNfts is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNfts does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgMintNfts) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNfts.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNfts.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNfts.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNfts.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNfts.nfts":
		m := new(MsgNftsMetadata)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "mantrachain.token.v1.MsgMintNfts.strict":
		return protoreflect.ValueOfBool(false)
	case "mantrachain.token.v1.MsgMintNfts.did":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNfts does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgMintNfts) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgMintNfts", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgMintNfts) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNfts) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgMintNfts) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgMintNfts) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgMintNfts)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Nfts != nil {
			l = options.Size(x.Nfts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Strict {
			n += 2
		}
		if x.Did {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNfts)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Did {
			i--
			if x.Did {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x38
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x30
		}
		if x.Nfts != nil {
			encoded, err := options.Marshal(x.Nfts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNfts)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNfts: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNfts: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nfts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Nfts == nil {
					x.Nfts = &MsgNftsMetadata{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Nfts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			case 7:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Did = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgMintNftsResponse_1_list)(nil)

type _MsgMintNftsResponse_1_list struct {
	list *[]string
}

func (x *_MsgMintNftsResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgMintNftsResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_MsgMintNftsResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgMintNftsResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgMintNftsResponse_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgMintNftsResponse at list field NftsIds as it is not of Message kind"))
}

func (x *_MsgMintNftsResponse_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgMintNftsResponse_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_MsgMintNftsResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgMintNftsResponse                    protoreflect.MessageDescriptor
	fd_MsgMintNftsResponse_nfts_ids           protoreflect.FieldDescriptor
	fd_MsgMintNftsResponse_nfts_count         protoreflect.FieldDescriptor
	fd_MsgMintNftsResponse_creator            protoreflect.FieldDescriptor
	fd_MsgMintNftsResponse_receiver           protoreflect.FieldDescriptor
	fd_MsgMintNftsResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgMintNftsResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgMintNftsResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgMintNftsResponse")
	fd_MsgMintNftsResponse_nfts_ids = md_MsgMintNftsResponse.Fields().ByName("nfts_ids")
	fd_MsgMintNftsResponse_nfts_count = md_MsgMintNftsResponse.Fields().ByName("nfts_count")
	fd_MsgMintNftsResponse_creator = md_MsgMintNftsResponse.Fields().ByName("creator")
	fd_MsgMintNftsResponse_receiver = md_MsgMintNftsResponse.Fields().ByName("receiver")
	fd_MsgMintNftsResponse_collection_creator = md_MsgMintNftsResponse.Fields().ByName("collection_creator")
	fd_MsgMintNftsResponse_collection_id = md_MsgMintNftsResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgMintNftsResponse)(nil)

type fastReflection_MsgMintNftsResponse MsgMintNftsResponse

func (x *MsgMintNftsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgMintNftsResponse)(x)
}

func (x *MsgMintNftsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgMintNftsResponse_messageType fastReflection_MsgMintNftsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgMintNftsResponse_messageType{}

type fastReflection_MsgMintNftsResponse_messageType struct{}

func (x fastReflection_MsgMintNftsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgMintNftsResponse)(nil)
}
func (x fastReflection_MsgMintNftsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgMintNftsResponse)
}
func (x fastReflection_MsgMintNftsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNftsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgMintNftsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgMintNftsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgMintNftsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgMintNftsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgMintNftsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgMintNftsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgMintNftsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgMintNftsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgMintNftsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NftsIds) != 0 {
		value := protoreflect.ValueOfList(&_MsgMintNftsResponse_1_list{list: &x.NftsIds})
		if !f(fd_MsgMintNftsResponse_nfts_ids, value) {
			return
		}
	}
	if x.NftsCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.NftsCount)
		if !f(fd_MsgMintNftsResponse_nfts_count, value) {
			return
		}
	}
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgMintNftsResponse_creator, value) {
			return
		}
	}
	if x.Receiver != "" {
		value := protoreflect.ValueOfString(x.Receiver)
		if !f(fd_MsgMintNftsResponse_receiver, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgMintNftsResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgMintNftsResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgMintNftsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_ids":
		return len(x.NftsIds) != 0
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_count":
		return x.NftsCount != uint32(0)
	case "mantrachain.token.v1.MsgMintNftsResponse.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgMintNftsResponse.receiver":
		return x.Receiver != ""
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_ids":
		x.NftsIds = nil
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_count":
		x.NftsCount = uint32(0)
	case "mantrachain.token.v1.MsgMintNftsResponse.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgMintNftsResponse.receiver":
		x.Receiver = ""
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgMintNftsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_ids":
		if len(x.NftsIds) == 0 {
			return protoreflect.ValueOfList(&_MsgMintNftsResponse_1_list{})
		}
		listValue := &_MsgMintNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(listValue)
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_count":
		value := x.NftsCount
		return protoreflect.ValueOfUint32(value)
	case "mantrachain.token.v1.MsgMintNftsResponse.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftsResponse.receiver":
		value := x.Receiver
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_ids":
		lv := value.List()
		clv := lv.(*_MsgMintNftsResponse_1_list)
		x.NftsIds = *clv.list
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_count":
		x.NftsCount = uint32(value.Uint())
	case "mantrachain.token.v1.MsgMintNftsResponse.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftsResponse.receiver":
		x.Receiver = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_ids":
		if x.NftsIds == nil {
			x.NftsIds = []string{}
		}
		value := &_MsgMintNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(value)
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_count":
		panic(fmt.Errorf("field nfts_count of message mantrachain.token.v1.MsgMintNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftsResponse.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgMintNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftsResponse.receiver":
		panic(fmt.Errorf("field receiver of message mantrachain.token.v1.MsgMintNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgMintNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgMintNftsResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgMintNftsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_ids":
		list := []string{}
		return protoreflect.ValueOfList(&_MsgMintNftsResponse_1_list{list: &list})
	case "mantrachain.token.v1.MsgMintNftsResponse.nfts_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "mantrachain.token.v1.MsgMintNftsResponse.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftsResponse.receiver":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgMintNftsResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgMintNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgMintNftsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgMintNftsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgMintNftsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgMintNftsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgMintNftsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgMintNftsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgMintNftsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgMintNftsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.NftsIds) > 0 {
			for _, s := range x.NftsIds {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NftsCount != 0 {
			n += 1 + runtime.Sov(uint64(x.NftsCount))
		}
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Receiver)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNftsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Receiver) > 0 {
			i -= len(x.Receiver)
			copy(dAtA[i:], x.Receiver)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Receiver)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NftsCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NftsCount))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NftsIds) > 0 {
			for iNdEx := len(x.NftsIds) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.NftsIds[iNdEx])
				copy(dAtA[i:], x.NftsIds[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftsIds[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgMintNftsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNftsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgMintNftsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsIds", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftsIds = append(x.NftsIds, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsCount", wireType)
				}
				x.NftsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NftsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Receiver = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MsgBurnNfts                    protoreflect.MessageDescriptor
	fd_MsgBurnNfts_creator            protoreflect.FieldDescriptor
	fd_MsgBurnNfts_collection_creator protoreflect.FieldDescriptor
	fd_MsgBurnNfts_collection_id      protoreflect.FieldDescriptor
	fd_MsgBurnNfts_nfts               protoreflect.FieldDescriptor
	fd_MsgBurnNfts_strict             protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgBurnNfts = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgBurnNfts")
	fd_MsgBurnNfts_creator = md_MsgBurnNfts.Fields().ByName("creator")
	fd_MsgBurnNfts_collection_creator = md_MsgBurnNfts.Fields().ByName("collection_creator")
	fd_MsgBurnNfts_collection_id = md_MsgBurnNfts.Fields().ByName("collection_id")
	fd_MsgBurnNfts_nfts = md_MsgBurnNfts.Fields().ByName("nfts")
	fd_MsgBurnNfts_strict = md_MsgBurnNfts.Fields().ByName("strict")
}

var _ protoreflect.Message = (*fastReflection_MsgBurnNfts)(nil)

type fastReflection_MsgBurnNfts MsgBurnNfts

func (x *MsgBurnNfts) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgBurnNfts)(x)
}

func (x *MsgBurnNfts) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgBurnNfts_messageType fastReflection_MsgBurnNfts_messageType
var _ protoreflect.MessageType = fastReflection_MsgBurnNfts_messageType{}

type fastReflection_MsgBurnNfts_messageType struct{}

func (x fastReflection_MsgBurnNfts_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgBurnNfts)(nil)
}
func (x fastReflection_MsgBurnNfts_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNfts)
}
func (x fastReflection_MsgBurnNfts_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNfts
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgBurnNfts) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNfts
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgBurnNfts) Type() protoreflect.MessageType {
	return _fastReflection_MsgBurnNfts_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgBurnNfts) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNfts)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgBurnNfts) Interface() protoreflect.ProtoMessage {
	return (*MsgBurnNfts)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgBurnNfts) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Creator != "" {
		value := protoreflect.ValueOfString(x.Creator)
		if !f(fd_MsgBurnNfts_creator, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgBurnNfts_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgBurnNfts_collection_id, value) {
			return
		}
	}
	if x.Nfts != nil {
		value := protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
		if !f(fd_MsgBurnNfts_nfts, value) {
			return
		}
	}
	if x.Strict != false {
		value := protoreflect.ValueOfBool(x.Strict)
		if !f(fd_MsgBurnNfts_strict, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgBurnNfts) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNfts.creator":
		return x.Creator != ""
	case "mantrachain.token.v1.MsgBurnNfts.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgBurnNfts.collection_id":
		return x.CollectionId != ""
	case "mantrachain.token.v1.MsgBurnNfts.nfts":
		return x.Nfts != nil
	case "mantrachain.token.v1.MsgBurnNfts.strict":
		return x.Strict != false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNfts does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNfts) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNfts.creator":
		x.Creator = ""
	case "mantrachain.token.v1.MsgBurnNfts.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgBurnNfts.collection_id":
		x.CollectionId = ""
	case "mantrachain.token.v1.MsgBurnNfts.nfts":
		x.Nfts = nil
	case "mantrachain.token.v1.MsgBurnNfts.strict":
		x.Strict = false
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNfts does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgBurnNfts) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgBurnNfts.creator":
		value := x.Creator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNfts.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNfts.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNfts.nfts":
		value := x.Nfts
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "mantrachain.token.v1.MsgBurnNfts.strict":
		value := x.Strict
		return protoreflect.ValueOfBool(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNfts does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNfts) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNfts.creator":
		x.Creator = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNfts.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNfts.collection_id":
		x.CollectionId = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNfts.nfts":
		x.Nfts = value.Message().Interface().(*MsgNftsIds)
	case "mantrachain.token.v1.MsgBurnNfts.strict":
		x.Strict = value.Bool()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNfts does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNfts) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNfts.nfts":
		if x.Nfts == nil {
			x.Nfts = new(MsgNftsIds)
		}
		return protoreflect.ValueOfMessage(x.Nfts.ProtoReflect())
	case "mantrachain.token.v1.MsgBurnNfts.creator":
		panic(fmt.Errorf("field creator of message mantrachain.token.v1.MsgBurnNfts is not mutable"))
	case "mantrachain.token.v1.MsgBurnNfts.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgBurnNfts is not mutable"))
	case "mantrachain.token.v1.MsgBurnNfts.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgBurnNfts is not mutable"))
	case "mantrachain.token.v1.MsgBurnNfts.strict":
		panic(fmt.Errorf("field strict of message mantrachain.token.v1.MsgBurnNfts is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNfts does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgBurnNfts) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNfts.creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNfts.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNfts.collection_id":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNfts.nfts":
		m := new(MsgNftsIds)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "mantrachain.token.v1.MsgBurnNfts.strict":
		return protoreflect.ValueOfBool(false)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNfts"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNfts does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgBurnNfts) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgBurnNfts", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgBurnNfts) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNfts) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgBurnNfts) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgBurnNfts) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgBurnNfts)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Creator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Nfts != nil {
			l = options.Size(x.Nfts)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Strict {
			n += 2
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNfts)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Strict {
			i--
			if x.Strict {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x28
		}
		if x.Nfts != nil {
			encoded, err := options.Marshal(x.Nfts)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Creator) > 0 {
			i -= len(x.Creator)
			copy(dAtA[i:], x.Creator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Creator)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNfts)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNfts: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNfts: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Creator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nfts", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Nfts == nil {
					x.Nfts = &MsgNftsIds{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Nfts); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
				}
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				x.Strict = bool(v != 0)
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_MsgBurnNftsResponse_1_list)(nil)

type _MsgBurnNftsResponse_1_list struct {
	list *[]string
}

func (x *_MsgBurnNftsResponse_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_MsgBurnNftsResponse_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_MsgBurnNftsResponse_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_MsgBurnNftsResponse_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_MsgBurnNftsResponse_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message MsgBurnNftsResponse at list field NftsIds as it is not of Message kind"))
}

func (x *_MsgBurnNftsResponse_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_MsgBurnNftsResponse_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_MsgBurnNftsResponse_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_MsgBurnNftsResponse                    protoreflect.MessageDescriptor
	fd_MsgBurnNftsResponse_nfts_ids           protoreflect.FieldDescriptor
	fd_MsgBurnNftsResponse_nfts_count         protoreflect.FieldDescriptor
	fd_MsgBurnNftsResponse_burner             protoreflect.FieldDescriptor
	fd_MsgBurnNftsResponse_collection_creator protoreflect.FieldDescriptor
	fd_MsgBurnNftsResponse_collection_id      protoreflect.FieldDescriptor
)

func init() {
	file_mantrachain_token_v1_tx_proto_init()
	md_MsgBurnNftsResponse = File_mantrachain_token_v1_tx_proto.Messages().ByName("MsgBurnNftsResponse")
	fd_MsgBurnNftsResponse_nfts_ids = md_MsgBurnNftsResponse.Fields().ByName("nfts_ids")
	fd_MsgBurnNftsResponse_nfts_count = md_MsgBurnNftsResponse.Fields().ByName("nfts_count")
	fd_MsgBurnNftsResponse_burner = md_MsgBurnNftsResponse.Fields().ByName("burner")
	fd_MsgBurnNftsResponse_collection_creator = md_MsgBurnNftsResponse.Fields().ByName("collection_creator")
	fd_MsgBurnNftsResponse_collection_id = md_MsgBurnNftsResponse.Fields().ByName("collection_id")
}

var _ protoreflect.Message = (*fastReflection_MsgBurnNftsResponse)(nil)

type fastReflection_MsgBurnNftsResponse MsgBurnNftsResponse

func (x *MsgBurnNftsResponse) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MsgBurnNftsResponse)(x)
}

func (x *MsgBurnNftsResponse) slowProtoReflect() protoreflect.Message {
	mi := &file_mantrachain_token_v1_tx_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MsgBurnNftsResponse_messageType fastReflection_MsgBurnNftsResponse_messageType
var _ protoreflect.MessageType = fastReflection_MsgBurnNftsResponse_messageType{}

type fastReflection_MsgBurnNftsResponse_messageType struct{}

func (x fastReflection_MsgBurnNftsResponse_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MsgBurnNftsResponse)(nil)
}
func (x fastReflection_MsgBurnNftsResponse_messageType) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNftsResponse)
}
func (x fastReflection_MsgBurnNftsResponse_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNftsResponse
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MsgBurnNftsResponse) Descriptor() protoreflect.MessageDescriptor {
	return md_MsgBurnNftsResponse
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MsgBurnNftsResponse) Type() protoreflect.MessageType {
	return _fastReflection_MsgBurnNftsResponse_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MsgBurnNftsResponse) New() protoreflect.Message {
	return new(fastReflection_MsgBurnNftsResponse)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MsgBurnNftsResponse) Interface() protoreflect.ProtoMessage {
	return (*MsgBurnNftsResponse)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MsgBurnNftsResponse) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.NftsIds) != 0 {
		value := protoreflect.ValueOfList(&_MsgBurnNftsResponse_1_list{list: &x.NftsIds})
		if !f(fd_MsgBurnNftsResponse_nfts_ids, value) {
			return
		}
	}
	if x.NftsCount != uint32(0) {
		value := protoreflect.ValueOfUint32(x.NftsCount)
		if !f(fd_MsgBurnNftsResponse_nfts_count, value) {
			return
		}
	}
	if x.Burner != "" {
		value := protoreflect.ValueOfString(x.Burner)
		if !f(fd_MsgBurnNftsResponse_burner, value) {
			return
		}
	}
	if x.CollectionCreator != "" {
		value := protoreflect.ValueOfString(x.CollectionCreator)
		if !f(fd_MsgBurnNftsResponse_collection_creator, value) {
			return
		}
	}
	if x.CollectionId != "" {
		value := protoreflect.ValueOfString(x.CollectionId)
		if !f(fd_MsgBurnNftsResponse_collection_id, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MsgBurnNftsResponse) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_ids":
		return len(x.NftsIds) != 0
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_count":
		return x.NftsCount != uint32(0)
	case "mantrachain.token.v1.MsgBurnNftsResponse.burner":
		return x.Burner != ""
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_creator":
		return x.CollectionCreator != ""
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_id":
		return x.CollectionId != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftsResponse) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_ids":
		x.NftsIds = nil
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_count":
		x.NftsCount = uint32(0)
	case "mantrachain.token.v1.MsgBurnNftsResponse.burner":
		x.Burner = ""
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_creator":
		x.CollectionCreator = ""
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_id":
		x.CollectionId = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MsgBurnNftsResponse) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_ids":
		if len(x.NftsIds) == 0 {
			return protoreflect.ValueOfList(&_MsgBurnNftsResponse_1_list{})
		}
		listValue := &_MsgBurnNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(listValue)
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_count":
		value := x.NftsCount
		return protoreflect.ValueOfUint32(value)
	case "mantrachain.token.v1.MsgBurnNftsResponse.burner":
		value := x.Burner
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_creator":
		value := x.CollectionCreator
		return protoreflect.ValueOfString(value)
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_id":
		value := x.CollectionId
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftsResponse does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftsResponse) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_ids":
		lv := value.List()
		clv := lv.(*_MsgBurnNftsResponse_1_list)
		x.NftsIds = *clv.list
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_count":
		x.NftsCount = uint32(value.Uint())
	case "mantrachain.token.v1.MsgBurnNftsResponse.burner":
		x.Burner = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_creator":
		x.CollectionCreator = value.Interface().(string)
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_id":
		x.CollectionId = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftsResponse does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftsResponse) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_ids":
		if x.NftsIds == nil {
			x.NftsIds = []string{}
		}
		value := &_MsgBurnNftsResponse_1_list{list: &x.NftsIds}
		return protoreflect.ValueOfList(value)
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_count":
		panic(fmt.Errorf("field nfts_count of message mantrachain.token.v1.MsgBurnNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgBurnNftsResponse.burner":
		panic(fmt.Errorf("field burner of message mantrachain.token.v1.MsgBurnNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_creator":
		panic(fmt.Errorf("field collection_creator of message mantrachain.token.v1.MsgBurnNftsResponse is not mutable"))
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_id":
		panic(fmt.Errorf("field collection_id of message mantrachain.token.v1.MsgBurnNftsResponse is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftsResponse does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MsgBurnNftsResponse) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_ids":
		list := []string{}
		return protoreflect.ValueOfList(&_MsgBurnNftsResponse_1_list{list: &list})
	case "mantrachain.token.v1.MsgBurnNftsResponse.nfts_count":
		return protoreflect.ValueOfUint32(uint32(0))
	case "mantrachain.token.v1.MsgBurnNftsResponse.burner":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_creator":
		return protoreflect.ValueOfString("")
	case "mantrachain.token.v1.MsgBurnNftsResponse.collection_id":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: mantrachain.token.v1.MsgBurnNftsResponse"))
		}
		panic(fmt.Errorf("message mantrachain.token.v1.MsgBurnNftsResponse does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MsgBurnNftsResponse) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in mantrachain.token.v1.MsgBurnNftsResponse", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MsgBurnNftsResponse) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MsgBurnNftsResponse) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MsgBurnNftsResponse) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MsgBurnNftsResponse) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MsgBurnNftsResponse)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.NftsIds) > 0 {
			for _, s := range x.NftsIds {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.NftsCount != 0 {
			n += 1 + runtime.Sov(uint64(x.NftsCount))
		}
		l = len(x.Burner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionCreator)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.CollectionId)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNftsResponse)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.CollectionId) > 0 {
			i -= len(x.CollectionId)
			copy(dAtA[i:], x.CollectionId)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionId)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.CollectionCreator) > 0 {
			i -= len(x.CollectionCreator)
			copy(dAtA[i:], x.CollectionCreator)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CollectionCreator)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Burner) > 0 {
			i -= len(x.Burner)
			copy(dAtA[i:], x.Burner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Burner)))
			i--
			dAtA[i] = 0x1a
		}
		if x.NftsCount != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NftsCount))
			i--
			dAtA[i] = 0x10
		}
		if len(x.NftsIds) > 0 {
			for iNdEx := len(x.NftsIds) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.NftsIds[iNdEx])
				copy(dAtA[i:], x.NftsIds[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NftsIds[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MsgBurnNftsResponse)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNftsResponse: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MsgBurnNftsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsIds", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NftsIds = append(x.NftsIds, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NftsCount", wireType)
				}
				x.NftsCount = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NftsCount |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Burner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Burner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionCreator", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionCreator = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CollectionId = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: mantrachain/token/v1/tx.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// authority is the address that controls the module (defaults to x/gov unless
	// overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the module parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params *Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params,omitempty"`
}

func (x *MsgUpdateParams) Reset() {
	*x = MsgUpdateParams{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateParams) ProtoMessage() {}

// Deprecated: Use MsgUpdateParams.ProtoReflect.Descriptor instead.
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{0}
}

func (x *MsgUpdateParams) GetAuthority() string {
	if x != nil {
		return x.Authority
	}
	return ""
}

func (x *MsgUpdateParams) GetParams() *Params {
	if x != nil {
		return x.Params
	}
	return nil
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *MsgUpdateParamsResponse) Reset() {
	*x = MsgUpdateParamsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateParamsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateParamsResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateParamsResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{1}
}

// MsgUpdateRestrictedCollectionNftImage
type MsgUpdateRestrictedCollectionNftImage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string               `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Owner             string               `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	CollectionCreator string               `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string               `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftId             string               `protobuf:"bytes,5,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Index             uint64               `protobuf:"varint,6,opt,name=index,proto3" json:"index,omitempty"`
	Image             *MsgNftImageMetadata `protobuf:"bytes,7,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *MsgUpdateRestrictedCollectionNftImage) Reset() {
	*x = MsgUpdateRestrictedCollectionNftImage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateRestrictedCollectionNftImage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateRestrictedCollectionNftImage) ProtoMessage() {}

// Deprecated: Use MsgUpdateRestrictedCollectionNftImage.ProtoReflect.Descriptor instead.
func (*MsgUpdateRestrictedCollectionNftImage) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{2}
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *MsgUpdateRestrictedCollectionNftImage) GetImage() *MsgNftImageMetadata {
	if x != nil {
		return x.Image
	}
	return nil
}

// MsgUpdateRestrictedCollectionNftImageResponse
type MsgUpdateRestrictedCollectionNftImageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftId             string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Owner             string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	CollectionCreator string `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) Reset() {
	*x = MsgUpdateRestrictedCollectionNftImageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateRestrictedCollectionNftImageResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateRestrictedCollectionNftImageResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateRestrictedCollectionNftImageResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{3}
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgUpdateRestrictedCollectionNftImageBatch
type MsgUpdateRestrictedCollectionNftImageBatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string                 `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CollectionCreator string                 `protobuf:"bytes,2,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string                 `protobuf:"bytes,3,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftsImages        *MsgNftsImagesMetadata `protobuf:"bytes,4,opt,name=nfts_images,json=nftsImages,proto3" json:"nfts_images,omitempty"`
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) Reset() {
	*x = MsgUpdateRestrictedCollectionNftImageBatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateRestrictedCollectionNftImageBatch) ProtoMessage() {}

// Deprecated: Use MsgUpdateRestrictedCollectionNftImageBatch.ProtoReflect.Descriptor instead.
func (*MsgUpdateRestrictedCollectionNftImageBatch) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{4}
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageBatch) GetNftsImages() *MsgNftsImagesMetadata {
	if x != nil {
		return x.NftsImages
	}
	return nil
}

// MsgUpdateRestrictedCollectionNftImageBatchResponse
type MsgUpdateRestrictedCollectionNftImageBatchResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftsIds           []string `protobuf:"bytes,1,rep,name=nfts_ids,json=nftsIds,proto3" json:"nfts_ids,omitempty"`
	NftsCount         uint32   `protobuf:"varint,2,opt,name=nfts_count,json=nftsCount,proto3" json:"nfts_count,omitempty"`
	CollectionCreator string   `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string   `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) Reset() {
	*x = MsgUpdateRestrictedCollectionNftImageBatchResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateRestrictedCollectionNftImageBatchResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateRestrictedCollectionNftImageBatchResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateRestrictedCollectionNftImageBatchResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{5}
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) GetNftsIds() []string {
	if x != nil {
		return x.NftsIds
	}
	return nil
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) GetNftsCount() uint32 {
	if x != nil {
		return x.NftsCount
	}
	return 0
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageBatchResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgUpdateRestrictedCollectionNftImageGroupedBatch
type MsgUpdateRestrictedCollectionNftImageGroupedBatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string                        `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CollectionCreator string                        `protobuf:"bytes,2,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string                        `protobuf:"bytes,3,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftsImagesGrouped *MsgNftsImagesGroupedMetadata `protobuf:"bytes,4,opt,name=nfts_images_grouped,json=nftsImagesGrouped,proto3" json:"nfts_images_grouped,omitempty"`
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) Reset() {
	*x = MsgUpdateRestrictedCollectionNftImageGroupedBatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateRestrictedCollectionNftImageGroupedBatch) ProtoMessage() {}

// Deprecated: Use MsgUpdateRestrictedCollectionNftImageGroupedBatch.ProtoReflect.Descriptor instead.
func (*MsgUpdateRestrictedCollectionNftImageGroupedBatch) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{6}
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatch) GetNftsImagesGrouped() *MsgNftsImagesGroupedMetadata {
	if x != nil {
		return x.NftsImagesGrouped
	}
	return nil
}

// MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse
type MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftsIds           []string `protobuf:"bytes,1,rep,name=nfts_ids,json=nftsIds,proto3" json:"nfts_ids,omitempty"`
	NftsCount         uint32   `protobuf:"varint,2,opt,name=nfts_count,json=nftsCount,proto3" json:"nfts_count,omitempty"`
	CollectionCreator string   `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string   `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Reset() {
	*x = MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{7}
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) GetNftsIds() []string {
	if x != nil {
		return x.NftsIds
	}
	return nil
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) GetNftsCount() uint32 {
	if x != nil {
		return x.NftsCount
	}
	return 0
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgUpdateGuardSoulBondNftImage
type MsgUpdateGuardSoulBondNftImage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator string               `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Owner   string               `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	NftId   string               `protobuf:"bytes,3,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Index   uint64               `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	Image   *MsgNftImageMetadata `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
}

func (x *MsgUpdateGuardSoulBondNftImage) Reset() {
	*x = MsgUpdateGuardSoulBondNftImage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateGuardSoulBondNftImage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateGuardSoulBondNftImage) ProtoMessage() {}

// Deprecated: Use MsgUpdateGuardSoulBondNftImage.ProtoReflect.Descriptor instead.
func (*MsgUpdateGuardSoulBondNftImage) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{8}
}

func (x *MsgUpdateGuardSoulBondNftImage) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgUpdateGuardSoulBondNftImage) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgUpdateGuardSoulBondNftImage) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgUpdateGuardSoulBondNftImage) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *MsgUpdateGuardSoulBondNftImage) GetImage() *MsgNftImageMetadata {
	if x != nil {
		return x.Image
	}
	return nil
}

// MsgUpdateGuardSoulBondNftImageResponse
type MsgUpdateGuardSoulBondNftImageResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftId             string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Owner             string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	CollectionCreator string `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) Reset() {
	*x = MsgUpdateGuardSoulBondNftImageResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgUpdateGuardSoulBondNftImageResponse) ProtoMessage() {}

// Deprecated: Use MsgUpdateGuardSoulBondNftImageResponse.ProtoReflect.Descriptor instead.
func (*MsgUpdateGuardSoulBondNftImageResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{9}
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgUpdateGuardSoulBondNftImageResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgApproveNft
type MsgApproveNft struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver          string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftId             string `protobuf:"bytes,5,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Approved          bool   `protobuf:"varint,6,opt,name=approved,proto3" json:"approved,omitempty"`
	Strict            bool   `protobuf:"varint,7,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgApproveNft) Reset() {
	*x = MsgApproveNft{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgApproveNft) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgApproveNft) ProtoMessage() {}

// Deprecated: Use MsgApproveNft.ProtoReflect.Descriptor instead.
func (*MsgApproveNft) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{10}
}

func (x *MsgApproveNft) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgApproveNft) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgApproveNft) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgApproveNft) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgApproveNft) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgApproveNft) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

func (x *MsgApproveNft) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgApproveNftResponse
type MsgApproveNftResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftId             string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Owner             string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver          string `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Approved          bool   `protobuf:"varint,4,opt,name=approved,proto3" json:"approved,omitempty"`
	CollectionCreator string `protobuf:"bytes,5,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,6,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgApproveNftResponse) Reset() {
	*x = MsgApproveNftResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgApproveNftResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgApproveNftResponse) ProtoMessage() {}

// Deprecated: Use MsgApproveNftResponse.ProtoReflect.Descriptor instead.
func (*MsgApproveNftResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{11}
}

func (x *MsgApproveNftResponse) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgApproveNftResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgApproveNftResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgApproveNftResponse) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

func (x *MsgApproveNftResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgApproveNftResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgTransferNft
type MsgTransferNft struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Owner             string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver          string `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string `protobuf:"bytes,4,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,5,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftId             string `protobuf:"bytes,6,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Strict            bool   `protobuf:"varint,7,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgTransferNft) Reset() {
	*x = MsgTransferNft{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgTransferNft) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgTransferNft) ProtoMessage() {}

// Deprecated: Use MsgTransferNft.ProtoReflect.Descriptor instead.
func (*MsgTransferNft) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{12}
}

func (x *MsgTransferNft) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgTransferNft) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgTransferNft) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgTransferNft) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgTransferNft) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgTransferNft) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgTransferNft) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgTransferNftResponse
type MsgTransferNftResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftId             string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Operator          string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	Owner             string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver          string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string `protobuf:"bytes,5,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,6,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgTransferNftResponse) Reset() {
	*x = MsgTransferNftResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgTransferNftResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgTransferNftResponse) ProtoMessage() {}

// Deprecated: Use MsgTransferNftResponse.ProtoReflect.Descriptor instead.
func (*MsgTransferNftResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{13}
}

func (x *MsgTransferNftResponse) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgTransferNftResponse) GetOperator() string {
	if x != nil {
		return x.Operator
	}
	return ""
}

func (x *MsgTransferNftResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgTransferNftResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgTransferNftResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgTransferNftResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgBurnNft
type MsgBurnNft struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CollectionCreator string `protobuf:"bytes,2,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,3,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	NftId             string `protobuf:"bytes,4,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Strict            bool   `protobuf:"varint,5,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgBurnNft) Reset() {
	*x = MsgBurnNft{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgBurnNft) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgBurnNft) ProtoMessage() {}

// Deprecated: Use MsgBurnNft.ProtoReflect.Descriptor instead.
func (*MsgBurnNft) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{14}
}

func (x *MsgBurnNft) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgBurnNft) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgBurnNft) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgBurnNft) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgBurnNft) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgBurnNftResponse
type MsgBurnNftResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftId             string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Burner            string `protobuf:"bytes,2,opt,name=burner,proto3" json:"burner,omitempty"`
	CollectionCreator string `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgBurnNftResponse) Reset() {
	*x = MsgBurnNftResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgBurnNftResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgBurnNftResponse) ProtoMessage() {}

// Deprecated: Use MsgBurnNftResponse.ProtoReflect.Descriptor instead.
func (*MsgBurnNftResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{15}
}

func (x *MsgBurnNftResponse) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgBurnNftResponse) GetBurner() string {
	if x != nil {
		return x.Burner
	}
	return ""
}

func (x *MsgBurnNftResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgBurnNftResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgMintNft
type MsgMintNft struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string          `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver          string          `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string          `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string          `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	Nft               *MsgNftMetadata `protobuf:"bytes,5,opt,name=nft,proto3" json:"nft,omitempty"`
	Strict            bool            `protobuf:"varint,6,opt,name=strict,proto3" json:"strict,omitempty"`
	Did               bool            `protobuf:"varint,7,opt,name=did,proto3" json:"did,omitempty"`
}

func (x *MsgMintNft) Reset() {
	*x = MsgMintNft{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgMintNft) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgMintNft) ProtoMessage() {}

// Deprecated: Use MsgMintNft.ProtoReflect.Descriptor instead.
func (*MsgMintNft) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{16}
}

func (x *MsgMintNft) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgMintNft) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgMintNft) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgMintNft) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgMintNft) GetNft() *MsgNftMetadata {
	if x != nil {
		return x.Nft
	}
	return nil
}

func (x *MsgMintNft) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

func (x *MsgMintNft) GetDid() bool {
	if x != nil {
		return x.Did
	}
	return false
}

// MsgMintNftResponse
type MsgMintNftResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftId             string `protobuf:"bytes,1,opt,name=nft_id,json=nftId,proto3" json:"nft_id,omitempty"`
	Creator           string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver          string `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string `protobuf:"bytes,4,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string `protobuf:"bytes,5,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgMintNftResponse) Reset() {
	*x = MsgMintNftResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgMintNftResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgMintNftResponse) ProtoMessage() {}

// Deprecated: Use MsgMintNftResponse.ProtoReflect.Descriptor instead.
func (*MsgMintNftResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{17}
}

func (x *MsgMintNftResponse) GetNftId() string {
	if x != nil {
		return x.NftId
	}
	return ""
}

func (x *MsgMintNftResponse) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgMintNftResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgMintNftResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgMintNftResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgNftsIds
type MsgApproveAllNfts struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Approved bool   `protobuf:"varint,3,opt,name=approved,proto3" json:"approved,omitempty"`
	Strict   bool   `protobuf:"varint,4,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgApproveAllNfts) Reset() {
	*x = MsgApproveAllNfts{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgApproveAllNfts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgApproveAllNfts) ProtoMessage() {}

// Deprecated: Use MsgApproveAllNfts.ProtoReflect.Descriptor instead.
func (*MsgApproveAllNfts) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{18}
}

func (x *MsgApproveAllNfts) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgApproveAllNfts) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgApproveAllNfts) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

func (x *MsgApproveAllNfts) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgApproveAllNftsResponse
type MsgApproveAllNftsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Owner    string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Approved bool   `protobuf:"varint,3,opt,name=approved,proto3" json:"approved,omitempty"`
}

func (x *MsgApproveAllNftsResponse) Reset() {
	*x = MsgApproveAllNftsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgApproveAllNftsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgApproveAllNftsResponse) ProtoMessage() {}

// Deprecated: Use MsgApproveAllNftsResponse.ProtoReflect.Descriptor instead.
func (*MsgApproveAllNftsResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{19}
}

func (x *MsgApproveAllNftsResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgApproveAllNftsResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgApproveAllNftsResponse) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

// MsgApproveNfts
type MsgApproveNfts struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string      `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver          string      `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string      `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string      `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	Nfts              *MsgNftsIds `protobuf:"bytes,5,opt,name=nfts,proto3" json:"nfts,omitempty"`
	Approved          bool        `protobuf:"varint,6,opt,name=approved,proto3" json:"approved,omitempty"`
	Strict            bool        `protobuf:"varint,7,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgApproveNfts) Reset() {
	*x = MsgApproveNfts{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgApproveNfts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgApproveNfts) ProtoMessage() {}

// Deprecated: Use MsgApproveNfts.ProtoReflect.Descriptor instead.
func (*MsgApproveNfts) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{20}
}

func (x *MsgApproveNfts) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgApproveNfts) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgApproveNfts) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgApproveNfts) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgApproveNfts) GetNfts() *MsgNftsIds {
	if x != nil {
		return x.Nfts
	}
	return nil
}

func (x *MsgApproveNfts) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

func (x *MsgApproveNfts) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgApproveNftsResponse
type MsgApproveNftsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftsIds           []string `protobuf:"bytes,1,rep,name=nfts_ids,json=nftsIds,proto3" json:"nfts_ids,omitempty"`
	NftsCount         uint32   `protobuf:"varint,2,opt,name=nfts_count,json=nftsCount,proto3" json:"nfts_count,omitempty"`
	Owner             string   `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver          string   `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Approved          bool     `protobuf:"varint,5,opt,name=approved,proto3" json:"approved,omitempty"`
	CollectionCreator string   `protobuf:"bytes,6,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string   `protobuf:"bytes,7,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgApproveNftsResponse) Reset() {
	*x = MsgApproveNftsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgApproveNftsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgApproveNftsResponse) ProtoMessage() {}

// Deprecated: Use MsgApproveNftsResponse.ProtoReflect.Descriptor instead.
func (*MsgApproveNftsResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{21}
}

func (x *MsgApproveNftsResponse) GetNftsIds() []string {
	if x != nil {
		return x.NftsIds
	}
	return nil
}

func (x *MsgApproveNftsResponse) GetNftsCount() uint32 {
	if x != nil {
		return x.NftsCount
	}
	return 0
}

func (x *MsgApproveNftsResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgApproveNftsResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgApproveNftsResponse) GetApproved() bool {
	if x != nil {
		return x.Approved
	}
	return false
}

func (x *MsgApproveNftsResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgApproveNftsResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgTransferNfts
type MsgTransferNfts struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string      `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Owner             string      `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver          string      `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string      `protobuf:"bytes,4,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string      `protobuf:"bytes,5,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	Nfts              *MsgNftsIds `protobuf:"bytes,6,opt,name=nfts,proto3" json:"nfts,omitempty"`
	Strict            bool        `protobuf:"varint,7,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgTransferNfts) Reset() {
	*x = MsgTransferNfts{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgTransferNfts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgTransferNfts) ProtoMessage() {}

// Deprecated: Use MsgTransferNfts.ProtoReflect.Descriptor instead.
func (*MsgTransferNfts) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{22}
}

func (x *MsgTransferNfts) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgTransferNfts) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgTransferNfts) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgTransferNfts) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgTransferNfts) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgTransferNfts) GetNfts() *MsgNftsIds {
	if x != nil {
		return x.Nfts
	}
	return nil
}

func (x *MsgTransferNfts) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgTransferNftsResponse
type MsgTransferNftsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftsIds           []string `protobuf:"bytes,1,rep,name=nfts_ids,json=nftsIds,proto3" json:"nfts_ids,omitempty"`
	NftsCount         uint32   `protobuf:"varint,2,opt,name=nfts_count,json=nftsCount,proto3" json:"nfts_count,omitempty"`
	Operator          string   `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
	Owner             string   `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	Receiver          string   `protobuf:"bytes,5,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string   `protobuf:"bytes,6,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string   `protobuf:"bytes,7,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgTransferNftsResponse) Reset() {
	*x = MsgTransferNftsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgTransferNftsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgTransferNftsResponse) ProtoMessage() {}

// Deprecated: Use MsgTransferNftsResponse.ProtoReflect.Descriptor instead.
func (*MsgTransferNftsResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{23}
}

func (x *MsgTransferNftsResponse) GetNftsIds() []string {
	if x != nil {
		return x.NftsIds
	}
	return nil
}

func (x *MsgTransferNftsResponse) GetNftsCount() uint32 {
	if x != nil {
		return x.NftsCount
	}
	return 0
}

func (x *MsgTransferNftsResponse) GetOperator() string {
	if x != nil {
		return x.Operator
	}
	return ""
}

func (x *MsgTransferNftsResponse) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *MsgTransferNftsResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgTransferNftsResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgTransferNftsResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgCreateNftCollection
type MsgCreateNftCollection struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator    string                          `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Collection *MsgCreateNftCollectionMetadata `protobuf:"bytes,2,opt,name=collection,proto3" json:"collection,omitempty"`
}

func (x *MsgCreateNftCollection) Reset() {
	*x = MsgCreateNftCollection{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgCreateNftCollection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgCreateNftCollection) ProtoMessage() {}

// Deprecated: Use MsgCreateNftCollection.ProtoReflect.Descriptor instead.
func (*MsgCreateNftCollection) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{24}
}

func (x *MsgCreateNftCollection) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgCreateNftCollection) GetCollection() *MsgCreateNftCollectionMetadata {
	if x != nil {
		return x.Collection
	}
	return nil
}

// MsgCreateNftCollectionResponse
type MsgCreateNftCollectionResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CollectionId      string `protobuf:"bytes,1,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	CollectionCreator string `protobuf:"bytes,2,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
}

func (x *MsgCreateNftCollectionResponse) Reset() {
	*x = MsgCreateNftCollectionResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgCreateNftCollectionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgCreateNftCollectionResponse) ProtoMessage() {}

// Deprecated: Use MsgCreateNftCollectionResponse.ProtoReflect.Descriptor instead.
func (*MsgCreateNftCollectionResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{25}
}

func (x *MsgCreateNftCollectionResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgCreateNftCollectionResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

// MsgMintNfts
type MsgMintNfts struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string           `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver          string           `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string           `protobuf:"bytes,3,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string           `protobuf:"bytes,4,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	Nfts              *MsgNftsMetadata `protobuf:"bytes,5,opt,name=nfts,proto3" json:"nfts,omitempty"`
	Strict            bool             `protobuf:"varint,6,opt,name=strict,proto3" json:"strict,omitempty"`
	Did               bool             `protobuf:"varint,7,opt,name=did,proto3" json:"did,omitempty"`
}

func (x *MsgMintNfts) Reset() {
	*x = MsgMintNfts{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgMintNfts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgMintNfts) ProtoMessage() {}

// Deprecated: Use MsgMintNfts.ProtoReflect.Descriptor instead.
func (*MsgMintNfts) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{26}
}

func (x *MsgMintNfts) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgMintNfts) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgMintNfts) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgMintNfts) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgMintNfts) GetNfts() *MsgNftsMetadata {
	if x != nil {
		return x.Nfts
	}
	return nil
}

func (x *MsgMintNfts) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

func (x *MsgMintNfts) GetDid() bool {
	if x != nil {
		return x.Did
	}
	return false
}

// MsgMintNftsResponse
type MsgMintNftsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftsIds           []string `protobuf:"bytes,1,rep,name=nfts_ids,json=nftsIds,proto3" json:"nfts_ids,omitempty"`
	NftsCount         uint32   `protobuf:"varint,2,opt,name=nfts_count,json=nftsCount,proto3" json:"nfts_count,omitempty"`
	Creator           string   `protobuf:"bytes,3,opt,name=creator,proto3" json:"creator,omitempty"`
	Receiver          string   `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
	CollectionCreator string   `protobuf:"bytes,5,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string   `protobuf:"bytes,6,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgMintNftsResponse) Reset() {
	*x = MsgMintNftsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgMintNftsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgMintNftsResponse) ProtoMessage() {}

// Deprecated: Use MsgMintNftsResponse.ProtoReflect.Descriptor instead.
func (*MsgMintNftsResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{27}
}

func (x *MsgMintNftsResponse) GetNftsIds() []string {
	if x != nil {
		return x.NftsIds
	}
	return nil
}

func (x *MsgMintNftsResponse) GetNftsCount() uint32 {
	if x != nil {
		return x.NftsCount
	}
	return 0
}

func (x *MsgMintNftsResponse) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgMintNftsResponse) GetReceiver() string {
	if x != nil {
		return x.Receiver
	}
	return ""
}

func (x *MsgMintNftsResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgMintNftsResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

// MsgBurnNfts
type MsgBurnNfts struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Creator           string      `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CollectionCreator string      `protobuf:"bytes,2,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string      `protobuf:"bytes,3,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	Nfts              *MsgNftsIds `protobuf:"bytes,4,opt,name=nfts,proto3" json:"nfts,omitempty"`
	Strict            bool        `protobuf:"varint,5,opt,name=strict,proto3" json:"strict,omitempty"`
}

func (x *MsgBurnNfts) Reset() {
	*x = MsgBurnNfts{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgBurnNfts) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgBurnNfts) ProtoMessage() {}

// Deprecated: Use MsgBurnNfts.ProtoReflect.Descriptor instead.
func (*MsgBurnNfts) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{28}
}

func (x *MsgBurnNfts) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *MsgBurnNfts) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgBurnNfts) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

func (x *MsgBurnNfts) GetNfts() *MsgNftsIds {
	if x != nil {
		return x.Nfts
	}
	return nil
}

func (x *MsgBurnNfts) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

// MsgBurnNftsResponse
type MsgBurnNftsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NftsIds           []string `protobuf:"bytes,1,rep,name=nfts_ids,json=nftsIds,proto3" json:"nfts_ids,omitempty"`
	NftsCount         uint32   `protobuf:"varint,2,opt,name=nfts_count,json=nftsCount,proto3" json:"nfts_count,omitempty"`
	Burner            string   `protobuf:"bytes,3,opt,name=burner,proto3" json:"burner,omitempty"`
	CollectionCreator string   `protobuf:"bytes,4,opt,name=collection_creator,json=collectionCreator,proto3" json:"collection_creator,omitempty"`
	CollectionId      string   `protobuf:"bytes,5,opt,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
}

func (x *MsgBurnNftsResponse) Reset() {
	*x = MsgBurnNftsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mantrachain_token_v1_tx_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MsgBurnNftsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MsgBurnNftsResponse) ProtoMessage() {}

// Deprecated: Use MsgBurnNftsResponse.ProtoReflect.Descriptor instead.
func (*MsgBurnNftsResponse) Descriptor() ([]byte, []int) {
	return file_mantrachain_token_v1_tx_proto_rawDescGZIP(), []int{29}
}

func (x *MsgBurnNftsResponse) GetNftsIds() []string {
	if x != nil {
		return x.NftsIds
	}
	return nil
}

func (x *MsgBurnNftsResponse) GetNftsCount() uint32 {
	if x != nil {
		return x.NftsCount
	}
	return 0
}

func (x *MsgBurnNftsResponse) GetBurner() string {
	if x != nil {
		return x.Burner
	}
	return ""
}

func (x *MsgBurnNftsResponse) GetCollectionCreator() string {
	if x != nil {
		return x.CollectionCreator
	}
	return ""
}

func (x *MsgBurnNftsResponse) GetCollectionId() string {
	if x != nil {
		return x.CollectionId
	}
	return ""
}

var File_mantrachain_token_v1_tx_proto protoreflect.FileDescriptor

var file_mantrachain_token_v1_tx_proto_rawDesc = []byte{
	0x0a, 0x1d, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x2f, 0x76, 0x31, 0x2f, 0x74, 0x78, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x14, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x2e, 0x76, 0x31, 0x1a, 0x11, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69,
	0x6e, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2f, 0x6d, 0x73, 0x67, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x73, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x19, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x67, 0x6f,
	0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x1a, 0x21, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x21, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc2, 0x01, 0x0a, 0x0f, 0x4d, 0x73, 0x67,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x36, 0x0a, 0x09,
	0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x09, 0x61, 0x75, 0x74, 0x68, 0x6f,
	0x72, 0x69, 0x74, 0x79, 0x12, 0x3f, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x72, 0x61,
	0x6d, 0x73, 0x42, 0x09, 0xc8, 0xde, 0x1f, 0x00, 0xa8, 0xe7, 0xb0, 0x2a, 0x01, 0x52, 0x06, 0x70,
	0x61, 0x72, 0x61, 0x6d, 0x73, 0x3a, 0x36, 0x82, 0xe7, 0xb0, 0x2a, 0x09, 0x61, 0x75, 0x74, 0x68,
	0x6f, 0x72, 0x69, 0x74, 0x79, 0x8a, 0xe7, 0xb0, 0x2a, 0x23, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73,
	0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x22, 0x19, 0x0a,
	0x17, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0xb3, 0x03, 0x0a, 0x25, 0x4d, 0x73, 0x67,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64,
	0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12,
	0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x69, 0x6e, 0x64, 0x65,
	0x78, 0x12, 0x3f, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x29, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4e, 0x66, 0x74, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x05, 0x69, 0x6d, 0x61,
	0x67, 0x65, 0x3a, 0x4a, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72,
	0x8a, 0xe7, 0xb0, 0x2a, 0x39, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x22, 0xca,
	0x01, 0x0a, 0x2d, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74,
	0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x47, 0x0a,
	0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xed, 0x02, 0x0a, 0x2a,
	0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63,
	0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72,
	0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d,
	0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53,
	0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x47,
	0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x4c, 0x0a, 0x0b,
	0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2b, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e,
	0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4e, 0x66, 0x74, 0x73,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x0a,
	0x6e, 0x66, 0x74, 0x73, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x3a, 0x4f, 0x82, 0xe7, 0xb0, 0x2a,
	0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x3e, 0x6d, 0x61, 0x6e,
	0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x2f, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69,
	0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66,
	0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x22, 0xdc, 0x01, 0x0a, 0x32,
	0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63,
	0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74,
	0x49, 0x6d, 0x61, 0x67, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x12, 0x1d, 0x0a,
	0x0a, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x09, 0x6e, 0x66, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x47, 0x0a, 0x12,
	0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69,
	0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72,
	0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x91, 0x03, 0x0a, 0x31, 0x4d,
	0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74,
	0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68,
	0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a,
	0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x49, 0x64, 0x12, 0x62, 0x0a, 0x13, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65,
	0x73, 0x5f, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x32, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4e, 0x66, 0x74, 0x73, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x73, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x4d, 0x65, 0x74, 0x61, 0x64,
	0x61, 0x74, 0x61, 0x52, 0x11, 0x6e, 0x66, 0x74, 0x73, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x73, 0x47,
	0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x3a, 0x56, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x45, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64,
	0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x22, 0xe3,
	0x01, 0x0a, 0x39, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74,
	0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x42,
	0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x19, 0x0a, 0x08,
	0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07,
	0x6e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x66, 0x74, 0x73, 0x5f,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6e, 0x66, 0x74,
	0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12,
	0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x22, 0xb7, 0x02, 0x0a, 0x1e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x47, 0x75, 0x61, 0x72, 0x64, 0x53, 0x6f, 0x75, 0x6c, 0x42, 0x6f, 0x6e, 0x64, 0x4e,
	0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69,
	0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x2e, 0x0a, 0x05, 0x6f,
	0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x15, 0x0a, 0x06, 0x6e,
	0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74,
	0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x3f, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67,
	0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d,
	0x73, 0x67, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61,
	0x74, 0x61, 0x52, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x3a, 0x43, 0x82, 0xe7, 0xb0, 0x2a, 0x07,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x32, 0x6d, 0x61, 0x6e, 0x74,
	0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f,
	0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x47, 0x75, 0x61, 0x72, 0x64, 0x53, 0x6f,
	0x75, 0x6c, 0x42, 0x6f, 0x6e, 0x64, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x22, 0xdd,
	0x01, 0x0a, 0x26, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x47, 0x75, 0x61, 0x72,
	0x64, 0x53, 0x6f, 0x75, 0x6c, 0x42, 0x6f, 0x6e, 0x64, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64,
	0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
	0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4,
	0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xe6,
	0x02, 0x0a, 0x0d, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74,
	0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64, 0x12,
	0x1a, 0x0a, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x73,
	0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x72,
	0x69, 0x63, 0x74, 0x3a, 0x32, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x21, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70,
	0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x22, 0xd0, 0x01, 0x0a, 0x15, 0x4d, 0x73, 0x67, 0x41,
	0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x1a,
	0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x61, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x12, 0x2d, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72,
	0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xe2, 0x02, 0x0a, 0x0e, 0x4d,
	0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x12, 0x32, 0x0a,
	0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18,
	0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65,
	0x72, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a,
	0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x15, 0x0a, 0x06, 0x6e,
	0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74,
	0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x3a, 0x33, 0x82, 0xe7, 0xb0, 0x2a,
	0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x22, 0x6d, 0x61, 0x6e,
	0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x2f, 0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x22,
	0xb9, 0x02, 0x0a, 0x16, 0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e,
	0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66,
	0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49,
	0x64, 0x12, 0x34, 0x0a, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69,
	0x76, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a,
	0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x8e, 0x02, 0x0a, 0x0a,
	0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72,
	0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d,
	0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53,
	0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x47,
	0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x15, 0x0a, 0x06,
	0x6e, 0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66,
	0x74, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x3a, 0x2f, 0x82, 0xe7, 0xb0,
	0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x1e, 0x6d, 0x61,
	0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x22, 0xb1, 0x01, 0x0a,
	0x12, 0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x62, 0x75,
	0x72, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x62, 0x75, 0x72, 0x6e,
	0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18,
	0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64,
	0x22, 0xf7, 0x02, 0x0a, 0x0a, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x12,
	0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x36, 0x0a, 0x03, 0x6e, 0x66, 0x74, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4e,
	0x66, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x03, 0x6e, 0x66, 0x74, 0x12,
	0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x69, 0x64, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x64, 0x69, 0x64, 0x3a, 0x2f, 0x82, 0xe7, 0xb0, 0x2a, 0x07,
	0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x1e, 0x6d, 0x61, 0x6e, 0x74,
	0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f,
	0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x22, 0x83, 0x02, 0x0a, 0x12, 0x4d,
	0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x15, 0x0a, 0x06, 0x6e, 0x66, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x6e, 0x66, 0x74, 0x49, 0x64, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18,
	0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76,
	0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18,
	0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64,
	0x22, 0xe9, 0x01, 0x0a, 0x11, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x41,
	0x6c, 0x6c, 0x4e, 0x66, 0x74, 0x73, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e,
	0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65,
	0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4,
	0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72,
	0x12, 0x1a, 0x0a, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74,
	0x72, 0x69, 0x63, 0x74, 0x3a, 0x36, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x25, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x41, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x65, 0x41, 0x6c, 0x6c, 0x4e, 0x66, 0x74, 0x73, 0x22, 0x9d, 0x01, 0x0a,
	0x19, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x41, 0x6c, 0x6c, 0x4e, 0x66,
	0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65,
	0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4,
	0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72,
	0x12, 0x1a, 0x0a, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x22, 0x87, 0x03, 0x0a,
	0x0e, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x73, 0x12,
	0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x04, 0x6e, 0x66, 0x74, 0x73, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67,
	0x4e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x52, 0x04, 0x6e, 0x66, 0x74, 0x73, 0x12, 0x1a, 0x0a,
	0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72,
	0x69, 0x63, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63,
	0x74, 0x3a, 0x33, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a,
	0xe7, 0xb0, 0x2a, 0x22, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f,
	0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f,
	0x76, 0x65, 0x4e, 0x66, 0x74, 0x73, 0x22, 0xc2, 0x02, 0x0a, 0x16, 0x4d, 0x73, 0x67, 0x41, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a,
	0x6e, 0x66, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x09, 0x6e, 0x66, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x2e, 0x0a, 0x05, 0x6f,
	0x77, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14,
	0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72,
	0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2,
	0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
	0x72, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x08, 0x61, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x64, 0x12, 0x47, 0x0a,
	0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x9d, 0x03, 0x0a, 0x0f,
	0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x73, 0x12,
	0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x05, 0x6f, 0x77,
	0x6e, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x04, 0x6e, 0x66, 0x74, 0x73, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67,
	0x4e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x52, 0x04, 0x6e, 0x66, 0x74, 0x73, 0x12, 0x16, 0x0a,
	0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x73,
	0x74, 0x72, 0x69, 0x63, 0x74, 0x3a, 0x34, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x23, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x73, 0x22, 0xdd, 0x02, 0x0a, 0x17,
	0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x73, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x66, 0x74, 0x73, 0x5f,
	0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x66, 0x74, 0x73, 0x49,
	0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6e, 0x66, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e,
	0x74, 0x12, 0x34, 0x0a, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x2e, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d,
	0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69,
	0x76, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a,
	0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xdf, 0x01, 0x0a, 0x16,
	0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x66, 0x74, 0x43, 0x6f, 0x6c, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e,
	0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x54, 0x0a, 0x0a, 0x63, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34,
	0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e,
	0x66, 0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x52, 0x0a, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x3a, 0x3b, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7,
	0xb0, 0x2a, 0x2a, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78,
	0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x4e, 0x66, 0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x8e, 0x01,
	0x0a, 0x1e, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x66, 0x74, 0x43, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x22, 0xfc,
	0x02, 0x0a, 0x0b, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x73, 0x12, 0x32,
	0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72,
	0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x08,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73,
	0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x11,
	0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x39, 0x0a, 0x04, 0x6e, 0x66, 0x74, 0x73, 0x18, 0x05,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4e,
	0x66, 0x74, 0x73, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x04, 0x6e, 0x66, 0x74,
	0x73, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x69, 0x64,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x64, 0x69, 0x64, 0x3a, 0x30, 0x82, 0xe7, 0xb0,
	0x2a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x1f, 0x6d, 0x61,
	0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x2f, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x73, 0x22, 0xa7, 0x02,
	0x0a, 0x13, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x64,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73,
	0x12, 0x1d, 0x0a, 0x0a, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6e, 0x66, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x12, 0x34, 0x0a, 0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x08, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x52,
	0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0xaf, 0x02, 0x0a, 0x0b, 0x4d, 0x73, 0x67, 0x42,
	0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x73, 0x12, 0x32, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74,
	0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69,
	0x6e, 0x67, 0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x47, 0x0a, 0x12, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f,
	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63, 0x6f, 0x73,
	0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72, 0x69, 0x6e,
	0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x72, 0x65,
	0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63, 0x6f, 0x6c,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x34, 0x0a, 0x04, 0x6e, 0x66, 0x74,
	0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d,
	0x73, 0x67, 0x4e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x52, 0x04, 0x6e, 0x66, 0x74, 0x73, 0x12,
	0x16, 0x0a, 0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x06, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x3a, 0x30, 0x82, 0xe7, 0xb0, 0x2a, 0x07, 0x63, 0x72,
	0x65, 0x61, 0x74, 0x6f, 0x72, 0x8a, 0xe7, 0xb0, 0x2a, 0x1f, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x78, 0x2f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2f, 0x4d, 0x73,
	0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x73, 0x22, 0xef, 0x01, 0x0a, 0x13, 0x4d, 0x73,
	0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x66, 0x74, 0x73, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x66, 0x74, 0x73, 0x49, 0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a,
	0x6e, 0x66, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x09, 0x6e, 0x66, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x30, 0x0a, 0x06, 0x62,
	0x75, 0x72, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d,
	0x14, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53,
	0x74, 0x72, 0x69, 0x6e, 0x67, 0x52, 0x06, 0x62, 0x75, 0x72, 0x6e, 0x65, 0x72, 0x12, 0x47, 0x0a,
	0x12, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x42, 0x18, 0xd2, 0xb4, 0x2d, 0x14, 0x63,
	0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x52, 0x11, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x63,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x32, 0x89, 0x0e, 0x0a, 0x03,
	0x4d, 0x73, 0x67, 0x12, 0x64, 0x0a, 0x0c, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72,
	0x61, 0x6d, 0x73, 0x12, 0x25, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x1a, 0x2d, 0x2e, 0x6d, 0x61, 0x6e,
	0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x79, 0x0a, 0x13, 0x43, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x4e, 0x66, 0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74,
	0x65, 0x4e, 0x66, 0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x34,
	0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e,
	0x66, 0x74, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x58, 0x0a, 0x08, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x73,
	0x12, 0x21, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e,
	0x66, 0x74, 0x73, 0x1a, 0x29, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4d, 0x69,
	0x6e, 0x74, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x58,
	0x0a, 0x08, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x73, 0x12, 0x21, 0x2e, 0x6d, 0x61, 0x6e,
	0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x73, 0x1a, 0x29, 0x2e,
	0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x64, 0x0a, 0x0c, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x73, 0x12, 0x25, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72,
	0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e,
	0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x73, 0x1a,
	0x2d, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x61,
	0x0a, 0x0b, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x73, 0x12, 0x24, 0x2e,
	0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e,
	0x66, 0x74, 0x73, 0x1a, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x41, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x6a, 0x0a, 0x0e, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x41, 0x6c, 0x6c, 0x4e,
	0x66, 0x74, 0x73, 0x12, 0x27, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69,
	0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x41, 0x70,
	0x70, 0x72, 0x6f, 0x76, 0x65, 0x41, 0x6c, 0x6c, 0x4e, 0x66, 0x74, 0x73, 0x1a, 0x2f, 0x2e, 0x6d,
	0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x41, 0x6c,
	0x6c, 0x4e, 0x66, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a,
	0x07, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x12, 0x20, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72,
	0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e,
	0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x1a, 0x28, 0x2e, 0x6d, 0x61, 0x6e,
	0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x4d, 0x73, 0x67, 0x4d, 0x69, 0x6e, 0x74, 0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x55, 0x0a, 0x07, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66, 0x74, 0x12,
	0x20, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e, 0x4e, 0x66,
	0x74, 0x1a, 0x28, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e,
	0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x42, 0x75, 0x72, 0x6e,
	0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x61, 0x0a, 0x0b, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x12, 0x24, 0x2e, 0x6d, 0x61, 0x6e,
	0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76,
	0x31, 0x2e, 0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x4e, 0x66, 0x74,
	0x1a, 0x2c, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74,
	0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x5e,
	0x0a, 0x0a, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x12, 0x23, 0x2e, 0x6d,
	0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x4e, 0x66,
	0x74, 0x1a, 0x2b, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e,
	0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x41, 0x70, 0x70, 0x72,
	0x6f, 0x76, 0x65, 0x4e, 0x66, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x91,
	0x01, 0x0a, 0x1b, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x47, 0x75, 0x61, 0x72, 0x64, 0x53, 0x6f,
	0x75, 0x6c, 0x42, 0x6f, 0x6e, 0x64, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x34,
	0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x47,
	0x75, 0x61, 0x72, 0x64, 0x53, 0x6f, 0x75, 0x6c, 0x42, 0x6f, 0x6e, 0x64, 0x4e, 0x66, 0x74, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x1a, 0x3c, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55,
	0x70, 0x64, 0x61, 0x74, 0x65, 0x47, 0x75, 0x61, 0x72, 0x64, 0x53, 0x6f, 0x75, 0x6c, 0x42, 0x6f,
	0x6e, 0x64, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0xa6, 0x01, 0x0a, 0x22, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73,
	0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12, 0x3b, 0x2e, 0x6d, 0x61, 0x6e, 0x74,
	0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69,
	0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66,
	0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x1a, 0x43, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73,
	0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65,
	0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0xb5, 0x01, 0x0a, 0x27,
	0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64,
	0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61,
	0x67, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x12, 0x40, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61,
	0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d,
	0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74,
	0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49,
	0x6d, 0x61, 0x67, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x1a, 0x48, 0x2e, 0x6d, 0x61, 0x6e, 0x74,
	0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69,
	0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66,
	0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0xca, 0x01, 0x0a, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65,
	0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x65,
	0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x12, 0x47, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63,
	0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73,
	0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65,
	0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d,
	0x61, 0x67, 0x65, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x1a,
	0x4f, 0x2e, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x73, 0x67, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x66, 0x74, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x47, 0x72, 0x6f, 0x75,
	0x70, 0x65, 0x64, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x1a, 0x05, 0x80, 0xe7, 0xb0, 0x2a, 0x01, 0x42, 0xc4, 0x01, 0x0a, 0x18, 0x63, 0x6f, 0x6d, 0x2e,
	0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2e, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x2e, 0x76, 0x31, 0x42, 0x07, 0x54, 0x78, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a,
	0x2d, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70,
	0x69, 0x2f, 0x6d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x2f, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x2f, 0x76, 0x31, 0x3b, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x76, 0x31, 0xa2, 0x02,
	0x03, 0x4d, 0x54, 0x58, 0xaa, 0x02, 0x14, 0x4d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61,
	0x69, 0x6e, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x14, 0x4d, 0x61,
	0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x5c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x5c,
	0x56, 0x31, 0xe2, 0x02, 0x20, 0x4d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68, 0x61, 0x69, 0x6e,
	0x5c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74,
	0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x16, 0x4d, 0x61, 0x6e, 0x74, 0x72, 0x61, 0x63, 0x68,
	0x61, 0x69, 0x6e, 0x3a, 0x3a, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_mantrachain_token_v1_tx_proto_rawDescOnce sync.Once
	file_mantrachain_token_v1_tx_proto_rawDescData = file_mantrachain_token_v1_tx_proto_rawDesc
)

func file_mantrachain_token_v1_tx_proto_rawDescGZIP() []byte {
	file_mantrachain_token_v1_tx_proto_rawDescOnce.Do(func() {
		file_mantrachain_token_v1_tx_proto_rawDescData = protoimpl.X.CompressGZIP(file_mantrachain_token_v1_tx_proto_rawDescData)
	})
	return file_mantrachain_token_v1_tx_proto_rawDescData
}

var file_mantrachain_token_v1_tx_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_mantrachain_token_v1_tx_proto_goTypes = []interface{}{
	(*MsgUpdateParams)(nil),                                           // 0: mantrachain.token.v1.MsgUpdateParams
	(*MsgUpdateParamsResponse)(nil),                                   // 1: mantrachain.token.v1.MsgUpdateParamsResponse
	(*MsgUpdateRestrictedCollectionNftImage)(nil),                     // 2: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage
	(*MsgUpdateRestrictedCollectionNftImageResponse)(nil),             // 3: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse
	(*MsgUpdateRestrictedCollectionNftImageBatch)(nil),                // 4: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch
	(*MsgUpdateRestrictedCollectionNftImageBatchResponse)(nil),        // 5: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse
	(*MsgUpdateRestrictedCollectionNftImageGroupedBatch)(nil),         // 6: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch
	(*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse)(nil), // 7: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse
	(*MsgUpdateGuardSoulBondNftImage)(nil),                            // 8: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage
	(*MsgUpdateGuardSoulBondNftImageResponse)(nil),                    // 9: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse
	(*MsgApproveNft)(nil),                                             // 10: mantrachain.token.v1.MsgApproveNft
	(*MsgApproveNftResponse)(nil),                                     // 11: mantrachain.token.v1.MsgApproveNftResponse
	(*MsgTransferNft)(nil),                                            // 12: mantrachain.token.v1.MsgTransferNft
	(*MsgTransferNftResponse)(nil),                                    // 13: mantrachain.token.v1.MsgTransferNftResponse
	(*MsgBurnNft)(nil),                                                // 14: mantrachain.token.v1.MsgBurnNft
	(*MsgBurnNftResponse)(nil),                                        // 15: mantrachain.token.v1.MsgBurnNftResponse
	(*MsgMintNft)(nil),                                                // 16: mantrachain.token.v1.MsgMintNft
	(*MsgMintNftResponse)(nil),                                        // 17: mantrachain.token.v1.MsgMintNftResponse
	(*MsgApproveAllNfts)(nil),                                         // 18: mantrachain.token.v1.MsgApproveAllNfts
	(*MsgApproveAllNftsResponse)(nil),                                 // 19: mantrachain.token.v1.MsgApproveAllNftsResponse
	(*MsgApproveNfts)(nil),                                            // 20: mantrachain.token.v1.MsgApproveNfts
	(*MsgApproveNftsResponse)(nil),                                    // 21: mantrachain.token.v1.MsgApproveNftsResponse
	(*MsgTransferNfts)(nil),                                           // 22: mantrachain.token.v1.MsgTransferNfts
	(*MsgTransferNftsResponse)(nil),                                   // 23: mantrachain.token.v1.MsgTransferNftsResponse
	(*MsgCreateNftCollection)(nil),                                    // 24: mantrachain.token.v1.MsgCreateNftCollection
	(*MsgCreateNftCollectionResponse)(nil),                            // 25: mantrachain.token.v1.MsgCreateNftCollectionResponse
	(*MsgMintNfts)(nil),                                               // 26: mantrachain.token.v1.MsgMintNfts
	(*MsgMintNftsResponse)(nil),                                       // 27: mantrachain.token.v1.MsgMintNftsResponse
	(*MsgBurnNfts)(nil),                                               // 28: mantrachain.token.v1.MsgBurnNfts
	(*MsgBurnNftsResponse)(nil),                                       // 29: mantrachain.token.v1.MsgBurnNftsResponse
	(*Params)(nil),                                                    // 30: mantrachain.token.v1.Params
	(*MsgNftImageMetadata)(nil),                                       // 31: mantrachain.token.v1.MsgNftImageMetadata
	(*MsgNftsImagesMetadata)(nil),                                     // 32: mantrachain.token.v1.MsgNftsImagesMetadata
	(*MsgNftsImagesGroupedMetadata)(nil),                              // 33: mantrachain.token.v1.MsgNftsImagesGroupedMetadata
	(*MsgNftMetadata)(nil),                                            // 34: mantrachain.token.v1.MsgNftMetadata
	(*MsgNftsIds)(nil),                                                // 35: mantrachain.token.v1.MsgNftsIds
	(*MsgCreateNftCollectionMetadata)(nil),                            // 36: mantrachain.token.v1.MsgCreateNftCollectionMetadata
	(*MsgNftsMetadata)(nil),                                           // 37: mantrachain.token.v1.MsgNftsMetadata
}
var file_mantrachain_token_v1_tx_proto_depIdxs = []int32{
	30, // 0: mantrachain.token.v1.MsgUpdateParams.params:type_name -> mantrachain.token.v1.Params
	31, // 1: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage.image:type_name -> mantrachain.token.v1.MsgNftImageMetadata
	32, // 2: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch.nfts_images:type_name -> mantrachain.token.v1.MsgNftsImagesMetadata
	33, // 3: mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch.nfts_images_grouped:type_name -> mantrachain.token.v1.MsgNftsImagesGroupedMetadata
	31, // 4: mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage.image:type_name -> mantrachain.token.v1.MsgNftImageMetadata
	34, // 5: mantrachain.token.v1.MsgMintNft.nft:type_name -> mantrachain.token.v1.MsgNftMetadata
	35, // 6: mantrachain.token.v1.MsgApproveNfts.nfts:type_name -> mantrachain.token.v1.MsgNftsIds
	35, // 7: mantrachain.token.v1.MsgTransferNfts.nfts:type_name -> mantrachain.token.v1.MsgNftsIds
	36, // 8: mantrachain.token.v1.MsgCreateNftCollection.collection:type_name -> mantrachain.token.v1.MsgCreateNftCollectionMetadata
	37, // 9: mantrachain.token.v1.MsgMintNfts.nfts:type_name -> mantrachain.token.v1.MsgNftsMetadata
	35, // 10: mantrachain.token.v1.MsgBurnNfts.nfts:type_name -> mantrachain.token.v1.MsgNftsIds
	0,  // 11: mantrachain.token.v1.Msg.UpdateParams:input_type -> mantrachain.token.v1.MsgUpdateParams
	24, // 12: mantrachain.token.v1.Msg.CreateNftCollection:input_type -> mantrachain.token.v1.MsgCreateNftCollection
	26, // 13: mantrachain.token.v1.Msg.MintNfts:input_type -> mantrachain.token.v1.MsgMintNfts
	28, // 14: mantrachain.token.v1.Msg.BurnNfts:input_type -> mantrachain.token.v1.MsgBurnNfts
	22, // 15: mantrachain.token.v1.Msg.TransferNfts:input_type -> mantrachain.token.v1.MsgTransferNfts
	20, // 16: mantrachain.token.v1.Msg.ApproveNfts:input_type -> mantrachain.token.v1.MsgApproveNfts
	18, // 17: mantrachain.token.v1.Msg.ApproveAllNfts:input_type -> mantrachain.token.v1.MsgApproveAllNfts
	16, // 18: mantrachain.token.v1.Msg.MintNft:input_type -> mantrachain.token.v1.MsgMintNft
	14, // 19: mantrachain.token.v1.Msg.BurnNft:input_type -> mantrachain.token.v1.MsgBurnNft
	12, // 20: mantrachain.token.v1.Msg.TransferNft:input_type -> mantrachain.token.v1.MsgTransferNft
	10, // 21: mantrachain.token.v1.Msg.ApproveNft:input_type -> mantrachain.token.v1.MsgApproveNft
	8,  // 22: mantrachain.token.v1.Msg.UpdateGuardSoulBondNftImage:input_type -> mantrachain.token.v1.MsgUpdateGuardSoulBondNftImage
	2,  // 23: mantrachain.token.v1.Msg.UpdateRestrictedCollectionNftImage:input_type -> mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImage
	4,  // 24: mantrachain.token.v1.Msg.UpdateRestrictedCollectionNftImageBatch:input_type -> mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatch
	6,  // 25: mantrachain.token.v1.Msg.UpdateRestrictedCollectionNftImageGroupedBatch:input_type -> mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatch
	1,  // 26: mantrachain.token.v1.Msg.UpdateParams:output_type -> mantrachain.token.v1.MsgUpdateParamsResponse
	25, // 27: mantrachain.token.v1.Msg.CreateNftCollection:output_type -> mantrachain.token.v1.MsgCreateNftCollectionResponse
	27, // 28: mantrachain.token.v1.Msg.MintNfts:output_type -> mantrachain.token.v1.MsgMintNftsResponse
	29, // 29: mantrachain.token.v1.Msg.BurnNfts:output_type -> mantrachain.token.v1.MsgBurnNftsResponse
	23, // 30: mantrachain.token.v1.Msg.TransferNfts:output_type -> mantrachain.token.v1.MsgTransferNftsResponse
	21, // 31: mantrachain.token.v1.Msg.ApproveNfts:output_type -> mantrachain.token.v1.MsgApproveNftsResponse
	19, // 32: mantrachain.token.v1.Msg.ApproveAllNfts:output_type -> mantrachain.token.v1.MsgApproveAllNftsResponse
	17, // 33: mantrachain.token.v1.Msg.MintNft:output_type -> mantrachain.token.v1.MsgMintNftResponse
	15, // 34: mantrachain.token.v1.Msg.BurnNft:output_type -> mantrachain.token.v1.MsgBurnNftResponse
	13, // 35: mantrachain.token.v1.Msg.TransferNft:output_type -> mantrachain.token.v1.MsgTransferNftResponse
	11, // 36: mantrachain.token.v1.Msg.ApproveNft:output_type -> mantrachain.token.v1.MsgApproveNftResponse
	9,  // 37: mantrachain.token.v1.Msg.UpdateGuardSoulBondNftImage:output_type -> mantrachain.token.v1.MsgUpdateGuardSoulBondNftImageResponse
	3,  // 38: mantrachain.token.v1.Msg.UpdateRestrictedCollectionNftImage:output_type -> mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageResponse
	5,  // 39: mantrachain.token.v1.Msg.UpdateRestrictedCollectionNftImageBatch:output_type -> mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageBatchResponse
	7,  // 40: mantrachain.token.v1.Msg.UpdateRestrictedCollectionNftImageGroupedBatch:output_type -> mantrachain.token.v1.MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse
	26, // [26:41] is the sub-list for method output_type
	11, // [11:26] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_mantrachain_token_v1_tx_proto_init() }
func file_mantrachain_token_v1_tx_proto_init() {
	if File_mantrachain_token_v1_tx_proto != nil {
		return
	}
	file_mantrachain_token_v1_params_proto_init()
	file_mantrachain_token_v1_common_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_mantrachain_token_v1_tx_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateParams); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateParamsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateRestrictedCollectionNftImage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateRestrictedCollectionNftImageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateRestrictedCollectionNftImageBatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateRestrictedCollectionNftImageBatchResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateRestrictedCollectionNftImageGroupedBatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateRestrictedCollectionNftImageGroupedBatchResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateGuardSoulBondNftImage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgUpdateGuardSoulBondNftImageResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgApproveNft); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgApproveNftResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgTransferNft); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgTransferNftResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgBurnNft); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgBurnNftResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgMintNft); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgMintNftResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgApproveAllNfts); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgApproveAllNftsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgApproveNfts); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgApproveNftsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgTransferNfts); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgTransferNftsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgCreateNftCollection); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgCreateNftCollectionResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgMintNfts); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgMintNftsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgBurnNfts); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mantrachain_token_v1_tx_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MsgBurnNftsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_mantrachain_token_v1_tx_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_mantrachain_token_v1_tx_proto_goTypes,
		DependencyIndexes: file_mantrachain_token_v1_tx_proto_depIdxs,
		MessageInfos:      file_mantrachain_token_v1_tx_proto_msgTypes,
	}.Build()
	File_mantrachain_token_v1_tx_proto = out.File
	file_mantrachain_token_v1_tx_proto_rawDesc = nil
	file_mantrachain_token_v1_tx_proto_goTypes = nil
	file_mantrachain_token_v1_tx_proto_depIdxs = nil
}
