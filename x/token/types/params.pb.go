// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: token/v1/params.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the module.
type Params struct {
	ValidNftCollectionId                               string `protobuf:"bytes,1,opt,name=valid_nft_collection_id,json=validNftCollectionId,proto3" json:"valid_nft_collection_id,omitempty"`
	NftCollectionDefaultId                             string `protobuf:"bytes,2,opt,name=nft_collection_default_id,json=nftCollectionDefaultId,proto3" json:"nft_collection_default_id,omitempty"`
	NftCollectionDefaultName                           string `protobuf:"bytes,3,opt,name=nft_collection_default_name,json=nftCollectionDefaultName,proto3" json:"nft_collection_default_name,omitempty"`
	ValidNftCollectionMetadataSymbolMinLength          int32  `protobuf:"varint,4,opt,name=valid_nft_collection_metadata_symbol_min_length,json=validNftCollectionMetadataSymbolMinLength,proto3" json:"valid_nft_collection_metadata_symbol_min_length,omitempty"`
	ValidNftCollectionMetadataSymbolMaxLength          int32  `protobuf:"varint,5,opt,name=valid_nft_collection_metadata_symbol_max_length,json=validNftCollectionMetadataSymbolMaxLength,proto3" json:"valid_nft_collection_metadata_symbol_max_length,omitempty"`
	ValidNftCollectionMetadataDescriptionMaxLength     int32  `protobuf:"varint,6,opt,name=valid_nft_collection_metadata_description_max_length,json=validNftCollectionMetadataDescriptionMaxLength,proto3" json:"valid_nft_collection_metadata_description_max_length,omitempty"`
	ValidNftCollectionMetadataNameMaxLength            int32  `protobuf:"varint,7,opt,name=valid_nft_collection_metadata_name_max_length,json=validNftCollectionMetadataNameMaxLength,proto3" json:"valid_nft_collection_metadata_name_max_length,omitempty"`
	ValidNftCollectionMetadataImagesMaxCount           int32  `protobuf:"varint,8,opt,name=valid_nft_collection_metadata_images_max_count,json=validNftCollectionMetadataImagesMaxCount,proto3" json:"valid_nft_collection_metadata_images_max_count,omitempty"`
	ValidNftCollectionMetadataImagesTypeMaxLength      int32  `protobuf:"varint,9,opt,name=valid_nft_collection_metadata_images_type_max_length,json=validNftCollectionMetadataImagesTypeMaxLength,proto3" json:"valid_nft_collection_metadata_images_type_max_length,omitempty"`
	ValidNftCollectionMetadataLinksMaxCount            int32  `protobuf:"varint,10,opt,name=valid_nft_collection_metadata_links_max_count,json=validNftCollectionMetadataLinksMaxCount,proto3" json:"valid_nft_collection_metadata_links_max_count,omitempty"`
	ValidNftCollectionMetadataLinksTypeMaxLength       int32  `protobuf:"varint,11,opt,name=valid_nft_collection_metadata_links_type_max_length,json=validNftCollectionMetadataLinksTypeMaxLength,proto3" json:"valid_nft_collection_metadata_links_type_max_length,omitempty"`
	ValidNftCollectionMetadataOptionsMaxCount          int32  `protobuf:"varint,12,opt,name=valid_nft_collection_metadata_options_max_count,json=validNftCollectionMetadataOptionsMaxCount,proto3" json:"valid_nft_collection_metadata_options_max_count,omitempty"`
	ValidNftCollectionMetadataOptionsTypeMaxLength     int32  `protobuf:"varint,13,opt,name=valid_nft_collection_metadata_options_type_max_length,json=validNftCollectionMetadataOptionsTypeMaxLength,proto3" json:"valid_nft_collection_metadata_options_type_max_length,omitempty"`
	ValidNftCollectionMetadataOptionsValueMaxLength    int32  `protobuf:"varint,14,opt,name=valid_nft_collection_metadata_options_value_max_length,json=validNftCollectionMetadataOptionsValueMaxLength,proto3" json:"valid_nft_collection_metadata_options_value_max_length,omitempty"`
	ValidNftCollectionMetadataOptionsSubValueMaxLength int32  `protobuf:"varint,15,opt,name=valid_nft_collection_metadata_options_sub_value_max_length,json=validNftCollectionMetadataOptionsSubValueMaxLength,proto3" json:"valid_nft_collection_metadata_options_sub_value_max_length,omitempty"`
	ValidNftId                                         string `protobuf:"bytes,16,opt,name=valid_nft_id,json=validNftId,proto3" json:"valid_nft_id,omitempty"`
	ValidNftMetadataMaxCount                           int32  `protobuf:"varint,17,opt,name=valid_nft_metadata_max_count,json=validNftMetadataMaxCount,proto3" json:"valid_nft_metadata_max_count,omitempty"`
	ValidNftMetadataTitleMaxLength                     int32  `protobuf:"varint,18,opt,name=valid_nft_metadata_title_max_length,json=validNftMetadataTitleMaxLength,proto3" json:"valid_nft_metadata_title_max_length,omitempty"`
	ValidNftMetadataDescriptionMaxLength               int32  `protobuf:"varint,19,opt,name=valid_nft_metadata_description_max_length,json=validNftMetadataDescriptionMaxLength,proto3" json:"valid_nft_metadata_description_max_length,omitempty"`
	ValidNftMetadataImagesMaxCount                     int32  `protobuf:"varint,20,opt,name=valid_nft_metadata_images_max_count,json=validNftMetadataImagesMaxCount,proto3" json:"valid_nft_metadata_images_max_count,omitempty"`
	ValidNftMetadataImagesTypeMaxLength                int32  `protobuf:"varint,21,opt,name=valid_nft_metadata_images_type_max_length,json=validNftMetadataImagesTypeMaxLength,proto3" json:"valid_nft_metadata_images_type_max_length,omitempty"`
	ValidNftMetadataLinksMaxCount                      int32  `protobuf:"varint,22,opt,name=valid_nft_metadata_links_max_count,json=validNftMetadataLinksMaxCount,proto3" json:"valid_nft_metadata_links_max_count,omitempty"`
	ValidNftMetadataLinksTypeMaxLength                 int32  `protobuf:"varint,23,opt,name=valid_nft_metadata_links_type_max_length,json=validNftMetadataLinksTypeMaxLength,proto3" json:"valid_nft_metadata_links_type_max_length,omitempty"`
	ValidNftMetadataAttributesMaxCount                 int32  `protobuf:"varint,24,opt,name=valid_nft_metadata_attributes_max_count,json=validNftMetadataAttributesMaxCount,proto3" json:"valid_nft_metadata_attributes_max_count,omitempty"`
	ValidNftMetadataAttributesTypeMaxLength            int32  `protobuf:"varint,25,opt,name=valid_nft_metadata_attributes_type_max_length,json=validNftMetadataAttributesTypeMaxLength,proto3" json:"valid_nft_metadata_attributes_type_max_length,omitempty"`
	ValidNftMetadataAttributesValueMaxLength           int32  `protobuf:"varint,26,opt,name=valid_nft_metadata_attributes_value_max_length,json=validNftMetadataAttributesValueMaxLength,proto3" json:"valid_nft_metadata_attributes_value_max_length,omitempty"`
	ValidNftMetadataAttributesSubValueMaxLength        int32  `protobuf:"varint,27,opt,name=valid_nft_metadata_attributes_sub_value_max_length,json=validNftMetadataAttributesSubValueMaxLength,proto3" json:"valid_nft_metadata_attributes_sub_value_max_length,omitempty"`
	ValidBurnNftMaxCount                               int32  `protobuf:"varint,28,opt,name=valid_burn_nft_max_count,json=validBurnNftMaxCount,proto3" json:"valid_burn_nft_max_count,omitempty"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_e52c112088923e84, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetValidNftCollectionId() string {
	if m != nil {
		return m.ValidNftCollectionId
	}
	return ""
}

func (m *Params) GetNftCollectionDefaultId() string {
	if m != nil {
		return m.NftCollectionDefaultId
	}
	return ""
}

func (m *Params) GetNftCollectionDefaultName() string {
	if m != nil {
		return m.NftCollectionDefaultName
	}
	return ""
}

func (m *Params) GetValidNftCollectionMetadataSymbolMinLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataSymbolMinLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataSymbolMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataSymbolMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataDescriptionMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataDescriptionMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataNameMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataNameMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataImagesMaxCount() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataImagesMaxCount
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataImagesTypeMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataImagesTypeMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataLinksMaxCount() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataLinksMaxCount
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataLinksTypeMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataLinksTypeMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataOptionsMaxCount() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataOptionsMaxCount
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataOptionsTypeMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataOptionsTypeMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataOptionsValueMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataOptionsValueMaxLength
	}
	return 0
}

func (m *Params) GetValidNftCollectionMetadataOptionsSubValueMaxLength() int32 {
	if m != nil {
		return m.ValidNftCollectionMetadataOptionsSubValueMaxLength
	}
	return 0
}

func (m *Params) GetValidNftId() string {
	if m != nil {
		return m.ValidNftId
	}
	return ""
}

func (m *Params) GetValidNftMetadataMaxCount() int32 {
	if m != nil {
		return m.ValidNftMetadataMaxCount
	}
	return 0
}

func (m *Params) GetValidNftMetadataTitleMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataTitleMaxLength
	}
	return 0
}

func (m *Params) GetValidNftMetadataDescriptionMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataDescriptionMaxLength
	}
	return 0
}

func (m *Params) GetValidNftMetadataImagesMaxCount() int32 {
	if m != nil {
		return m.ValidNftMetadataImagesMaxCount
	}
	return 0
}

func (m *Params) GetValidNftMetadataImagesTypeMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataImagesTypeMaxLength
	}
	return 0
}

func (m *Params) GetValidNftMetadataLinksMaxCount() int32 {
	if m != nil {
		return m.ValidNftMetadataLinksMaxCount
	}
	return 0
}

func (m *Params) GetValidNftMetadataLinksTypeMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataLinksTypeMaxLength
	}
	return 0
}

func (m *Params) GetValidNftMetadataAttributesMaxCount() int32 {
	if m != nil {
		return m.ValidNftMetadataAttributesMaxCount
	}
	return 0
}

func (m *Params) GetValidNftMetadataAttributesTypeMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataAttributesTypeMaxLength
	}
	return 0
}

func (m *Params) GetValidNftMetadataAttributesValueMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataAttributesValueMaxLength
	}
	return 0
}

func (m *Params) GetValidNftMetadataAttributesSubValueMaxLength() int32 {
	if m != nil {
		return m.ValidNftMetadataAttributesSubValueMaxLength
	}
	return 0
}

func (m *Params) GetValidBurnNftMaxCount() int32 {
	if m != nil {
		return m.ValidBurnNftMaxCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "LimeChain.mantrachain.token.v1.Params")
}

func init() { proto.RegisterFile("token/v1/params.proto", fileDescriptor_e52c112088923e84) }

var fileDescriptor_e52c112088923e84 = []byte{
	// 742 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x96, 0xcb, 0x4e, 0xdb, 0x4c,
	0x14, 0xc7, 0x93, 0xef, 0x03, 0x5a, 0xa6, 0xf4, 0x66, 0x6e, 0xe6, 0x52, 0x17, 0x41, 0x25, 0x82,
	0x5a, 0x6c, 0x01, 0x05, 0xa9, 0x48, 0xad, 0x54, 0x60, 0xd1, 0xa8, 0x40, 0x2b, 0x40, 0x54, 0xea,
	0xa2, 0xee, 0x38, 0x36, 0x61, 0x84, 0x3d, 0x8e, 0x9c, 0x71, 0x14, 0xde, 0xa2, 0xcb, 0x2e, 0xfb,
	0x0a, 0x7d, 0x8b, 0x2e, 0x59, 0x76, 0x59, 0x91, 0x17, 0xa9, 0x7c, 0x9c, 0xd8, 0x99, 0xf1, 0x38,
	0x4e, 0x77, 0x51, 0xe6, 0xfc, 0xff, 0xbf, 0x73, 0xce, 0xcc, 0x1c, 0x0f, 0x9a, 0x66, 0xfe, 0x95,
	0x43, 0x8d, 0xd6, 0x86, 0xd1, 0xc0, 0x01, 0xf6, 0x9a, 0x7a, 0x23, 0xf0, 0x99, 0xaf, 0x68, 0x87,
	0xc4, 0x73, 0xf6, 0x2f, 0x31, 0xa1, 0xba, 0x87, 0x29, 0x0b, 0x70, 0x0d, 0x7e, 0x43, 0xb0, 0xde,
	0xda, 0x98, 0x9f, 0xaa, 0xfb, 0x75, 0x1f, 0x42, 0x8d, 0xe8, 0x57, 0xac, 0x5a, 0xfe, 0x39, 0x89,
	0xc6, 0x3e, 0x82, 0x8d, 0xb2, 0x8d, 0x66, 0x5b, 0xd8, 0x25, 0xb6, 0x49, 0x2f, 0x98, 0x59, 0xf3,
	0x5d, 0xd7, 0xa9, 0x31, 0xe2, 0x53, 0x93, 0xd8, 0x6a, 0x79, 0xa9, 0x5c, 0x19, 0x3f, 0x99, 0x82,
	0xe5, 0xe3, 0x0b, 0xb6, 0x9f, 0x2c, 0x56, 0x6d, 0xe5, 0x15, 0x9a, 0x13, 0x04, 0xb6, 0x73, 0x81,
	0x43, 0x97, 0x45, 0xc2, 0xff, 0x40, 0x38, 0x43, 0xfb, 0x35, 0x07, 0xf1, 0x72, 0xd5, 0x56, 0x5e,
	0xa3, 0x85, 0x1c, 0x29, 0xc5, 0x9e, 0xa3, 0xfe, 0x0f, 0x62, 0x55, 0x26, 0x3e, 0xc6, 0x9e, 0xa3,
	0x58, 0xc8, 0x90, 0x26, 0xec, 0x39, 0x0c, 0xdb, 0x98, 0x61, 0xb3, 0x79, 0xed, 0x59, 0xbe, 0x6b,
	0x7a, 0x84, 0x9a, 0xae, 0x43, 0xeb, 0xec, 0x52, 0x1d, 0x59, 0x2a, 0x57, 0x46, 0x4f, 0xd6, 0xb2,
	0x85, 0x1c, 0x75, 0x35, 0xa7, 0x20, 0x39, 0x22, 0xf4, 0x10, 0x04, 0xc3, 0x33, 0x70, 0xbb, 0xc7,
	0x18, 0x1d, 0x92, 0x81, 0xdb, 0x5d, 0x86, 0x8b, 0x5e, 0x0e, 0x66, 0xd8, 0x4e, 0xb3, 0x16, 0x90,
	0x46, 0xfc, 0x67, 0x0a, 0x1a, 0x03, 0x90, 0x9e, 0x0f, 0x3a, 0x48, 0x75, 0x29, 0xed, 0x0b, 0x5a,
	0x1f, 0x4c, 0x8b, 0x7a, 0xdf, 0x8f, 0xb9, 0x03, 0x98, 0xd5, 0x7c, 0x4c, 0xb4, 0x19, 0xa9, 0xff,
	0x57, 0xa4, 0x0f, 0xf6, 0x27, 0x1e, 0xae, 0x3b, 0x4d, 0x20, 0xd4, 0xfc, 0x90, 0x32, 0xf5, 0x2e,
	0x00, 0x2a, 0xf9, 0x80, 0x2a, 0x28, 0x8e, 0x70, 0x7b, 0x3f, 0x8a, 0x57, 0xae, 0x8a, 0xfa, 0xd5,
	0x25, 0xb0, 0xeb, 0x06, 0x57, 0xc8, 0x38, 0x70, 0xd6, 0x8b, 0x38, 0x67, 0xd7, 0x0d, 0xe7, 0x1f,
	0xda, 0xe5, 0x12, 0x7a, 0xd5, 0x5f, 0x0d, 0x2a, 0x6a, 0xd7, 0x61, 0x24, 0x48, 0x8a, 0x21, 0x68,
	0x6b, 0x18, 0x7f, 0xb1, 0x96, 0x7b, 0x40, 0x79, 0x51, 0x40, 0xe1, 0x4b, 0x29, 0x3c, 0xcb, 0x3e,
	0x1c, 0x95, 0xfe, 0x62, 0x26, 0x8a, 0xce, 0xf2, 0x87, 0x58, 0x92, 0x94, 0xe3, 0xa1, 0xed, 0xe1,
	0x18, 0x62, 0x41, 0xf7, 0x8b, 0x0e, 0x73, 0x97, 0xc4, 0x97, 0xe4, 0xa3, 0x9d, 0xe1, 0x70, 0x2d,
	0xec, 0x86, 0x1c, 0xef, 0x01, 0xf0, 0x8c, 0x42, 0xde, 0x79, 0x24, 0x4c, 0x81, 0x2d, 0xb4, 0x3b,
	0x1c, 0xb0, 0x19, 0x5a, 0x59, 0xe8, 0x43, 0x80, 0x6e, 0x16, 0x42, 0x4f, 0x43, 0x4b, 0xe0, 0x2e,
	0xa1, 0x89, 0x94, 0x4b, 0x6c, 0xf5, 0x11, 0xcc, 0x46, 0xd4, 0x73, 0xaa, 0xda, 0xca, 0x1b, 0xb4,
	0x98, 0x46, 0x24, 0xe9, 0xa4, 0x5b, 0xf9, 0x18, 0xd8, 0x6a, 0x4f, 0xd1, 0x23, 0x26, 0x3b, 0xf7,
	0x1e, 0xad, 0x48, 0xf4, 0x8c, 0x30, 0x97, 0x2b, 0x41, 0x01, 0x1b, 0x4d, 0xb4, 0x39, 0x8b, 0xe2,
	0xd2, 0x74, 0x3f, 0xa1, 0x35, 0x89, 0x59, 0xce, 0x1c, 0x9b, 0x04, 0xcb, 0x67, 0xa2, 0xa5, 0x74,
	0x7a, 0xc9, 0xb3, 0xcc, 0x8c, 0x94, 0x29, 0x79, 0x96, 0xc2, 0x20, 0x39, 0x97, 0x66, 0x99, 0x33,
	0x3d, 0xa6, 0xc1, 0x72, 0x45, 0x6e, 0xc9, 0x9f, 0xca, 0x2a, 0x5a, 0x96, 0xf8, 0x8a, 0x83, 0x62,
	0x06, 0x0c, 0x9f, 0x88, 0x86, 0xfc, 0x78, 0x38, 0x43, 0x95, 0x5c, 0x2b, 0x31, 0xc3, 0x59, 0x30,
	0x5c, 0x96, 0x1a, 0xf2, 0x09, 0x9e, 0xa2, 0x55, 0x89, 0x2b, 0x66, 0x2c, 0x20, 0x56, 0xc8, 0xb8,
	0x4e, 0xaa, 0x72, 0xd3, 0xb7, 0x49, 0x6c, 0x92, 0x2a, 0x37, 0x29, 0x65, 0xa6, 0x62, 0xbe, 0x73,
	0xfc, 0xa4, 0xcc, 0x5a, 0xf3, 0x49, 0x73, 0x1f, 0x16, 0x99, 0x7f, 0xe6, 0xba, 0xcd, 0xf3, 0x1f,
	0x96, 0x2c, 0x40, 0xb8, 0x64, 0x75, 0xb4, 0x39, 0x98, 0x20, 0xbd, 0xd4, 0x0b, 0x40, 0x79, 0x9e,
	0x4f, 0xc9, 0xde, 0xe6, 0x1d, 0x14, 0xdf, 0x43, 0xd3, 0x0a, 0x03, 0x1a, 0xd3, 0x92, 0x86, 0x2f,
	0x82, 0x5d, 0xfc, 0xd6, 0xda, 0x0b, 0x03, 0x1a, 0x59, 0x76, 0x5b, 0xbc, 0x3b, 0xf2, 0xfd, 0xc7,
	0xd3, 0xd2, 0xde, 0xbb, 0x5f, 0xb7, 0x5a, 0xf9, 0xe6, 0x56, 0x2b, 0xff, 0xb9, 0xd5, 0xca, 0xdf,
	0x3a, 0x5a, 0xe9, 0xa6, 0xa3, 0x95, 0x7e, 0x77, 0xb4, 0xd2, 0x67, 0xbd, 0x4e, 0xd8, 0x65, 0x68,
	0xe9, 0x35, 0xdf, 0x33, 0x92, 0xe7, 0xa0, 0xd1, 0xf7, 0x1c, 0x34, 0xda, 0x46, 0xfc, 0x7a, 0x8c,
	0xf6, 0xa2, 0x69, 0x8d, 0xc1, 0x23, 0x70, 0xeb, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x23, 0x30,
	0x81, 0x68, 0x53, 0x0a, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidBurnNftMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidBurnNftMaxCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.ValidNftMetadataAttributesSubValueMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataAttributesSubValueMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.ValidNftMetadataAttributesValueMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataAttributesValueMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.ValidNftMetadataAttributesTypeMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataAttributesTypeMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.ValidNftMetadataAttributesMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataAttributesMaxCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ValidNftMetadataLinksTypeMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataLinksTypeMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.ValidNftMetadataLinksMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataLinksMaxCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.ValidNftMetadataImagesTypeMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataImagesTypeMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.ValidNftMetadataImagesMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataImagesMaxCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ValidNftMetadataDescriptionMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataDescriptionMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ValidNftMetadataTitleMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataTitleMaxLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ValidNftMetadataMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftMetadataMaxCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.ValidNftId) > 0 {
		i -= len(m.ValidNftId)
		copy(dAtA[i:], m.ValidNftId)
		i = encodeVarintParams(dAtA, i, uint64(len(m.ValidNftId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ValidNftCollectionMetadataOptionsSubValueMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataOptionsSubValueMaxLength))
		i--
		dAtA[i] = 0x78
	}
	if m.ValidNftCollectionMetadataOptionsValueMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataOptionsValueMaxLength))
		i--
		dAtA[i] = 0x70
	}
	if m.ValidNftCollectionMetadataOptionsTypeMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataOptionsTypeMaxLength))
		i--
		dAtA[i] = 0x68
	}
	if m.ValidNftCollectionMetadataOptionsMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataOptionsMaxCount))
		i--
		dAtA[i] = 0x60
	}
	if m.ValidNftCollectionMetadataLinksTypeMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataLinksTypeMaxLength))
		i--
		dAtA[i] = 0x58
	}
	if m.ValidNftCollectionMetadataLinksMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataLinksMaxCount))
		i--
		dAtA[i] = 0x50
	}
	if m.ValidNftCollectionMetadataImagesTypeMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataImagesTypeMaxLength))
		i--
		dAtA[i] = 0x48
	}
	if m.ValidNftCollectionMetadataImagesMaxCount != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataImagesMaxCount))
		i--
		dAtA[i] = 0x40
	}
	if m.ValidNftCollectionMetadataNameMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataNameMaxLength))
		i--
		dAtA[i] = 0x38
	}
	if m.ValidNftCollectionMetadataDescriptionMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataDescriptionMaxLength))
		i--
		dAtA[i] = 0x30
	}
	if m.ValidNftCollectionMetadataSymbolMaxLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataSymbolMaxLength))
		i--
		dAtA[i] = 0x28
	}
	if m.ValidNftCollectionMetadataSymbolMinLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ValidNftCollectionMetadataSymbolMinLength))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NftCollectionDefaultName) > 0 {
		i -= len(m.NftCollectionDefaultName)
		copy(dAtA[i:], m.NftCollectionDefaultName)
		i = encodeVarintParams(dAtA, i, uint64(len(m.NftCollectionDefaultName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NftCollectionDefaultId) > 0 {
		i -= len(m.NftCollectionDefaultId)
		copy(dAtA[i:], m.NftCollectionDefaultId)
		i = encodeVarintParams(dAtA, i, uint64(len(m.NftCollectionDefaultId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidNftCollectionId) > 0 {
		i -= len(m.ValidNftCollectionId)
		copy(dAtA[i:], m.ValidNftCollectionId)
		i = encodeVarintParams(dAtA, i, uint64(len(m.ValidNftCollectionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidNftCollectionId)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.NftCollectionDefaultId)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	l = len(m.NftCollectionDefaultName)
	if l > 0 {
		n += 1 + l + sovParams(uint64(l))
	}
	if m.ValidNftCollectionMetadataSymbolMinLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataSymbolMinLength))
	}
	if m.ValidNftCollectionMetadataSymbolMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataSymbolMaxLength))
	}
	if m.ValidNftCollectionMetadataDescriptionMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataDescriptionMaxLength))
	}
	if m.ValidNftCollectionMetadataNameMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataNameMaxLength))
	}
	if m.ValidNftCollectionMetadataImagesMaxCount != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataImagesMaxCount))
	}
	if m.ValidNftCollectionMetadataImagesTypeMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataImagesTypeMaxLength))
	}
	if m.ValidNftCollectionMetadataLinksMaxCount != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataLinksMaxCount))
	}
	if m.ValidNftCollectionMetadataLinksTypeMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataLinksTypeMaxLength))
	}
	if m.ValidNftCollectionMetadataOptionsMaxCount != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataOptionsMaxCount))
	}
	if m.ValidNftCollectionMetadataOptionsTypeMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataOptionsTypeMaxLength))
	}
	if m.ValidNftCollectionMetadataOptionsValueMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataOptionsValueMaxLength))
	}
	if m.ValidNftCollectionMetadataOptionsSubValueMaxLength != 0 {
		n += 1 + sovParams(uint64(m.ValidNftCollectionMetadataOptionsSubValueMaxLength))
	}
	l = len(m.ValidNftId)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	if m.ValidNftMetadataMaxCount != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataMaxCount))
	}
	if m.ValidNftMetadataTitleMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataTitleMaxLength))
	}
	if m.ValidNftMetadataDescriptionMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataDescriptionMaxLength))
	}
	if m.ValidNftMetadataImagesMaxCount != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataImagesMaxCount))
	}
	if m.ValidNftMetadataImagesTypeMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataImagesTypeMaxLength))
	}
	if m.ValidNftMetadataLinksMaxCount != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataLinksMaxCount))
	}
	if m.ValidNftMetadataLinksTypeMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataLinksTypeMaxLength))
	}
	if m.ValidNftMetadataAttributesMaxCount != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataAttributesMaxCount))
	}
	if m.ValidNftMetadataAttributesTypeMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataAttributesTypeMaxLength))
	}
	if m.ValidNftMetadataAttributesValueMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataAttributesValueMaxLength))
	}
	if m.ValidNftMetadataAttributesSubValueMaxLength != 0 {
		n += 2 + sovParams(uint64(m.ValidNftMetadataAttributesSubValueMaxLength))
	}
	if m.ValidBurnNftMaxCount != 0 {
		n += 2 + sovParams(uint64(m.ValidBurnNftMaxCount))
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidNftCollectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftCollectionDefaultId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftCollectionDefaultId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftCollectionDefaultName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftCollectionDefaultName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataSymbolMinLength", wireType)
			}
			m.ValidNftCollectionMetadataSymbolMinLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataSymbolMinLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataSymbolMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataSymbolMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataSymbolMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataDescriptionMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataDescriptionMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataDescriptionMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataNameMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataNameMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataNameMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataImagesMaxCount", wireType)
			}
			m.ValidNftCollectionMetadataImagesMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataImagesMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataImagesTypeMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataImagesTypeMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataImagesTypeMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataLinksMaxCount", wireType)
			}
			m.ValidNftCollectionMetadataLinksMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataLinksMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataLinksTypeMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataLinksTypeMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataLinksTypeMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataOptionsMaxCount", wireType)
			}
			m.ValidNftCollectionMetadataOptionsMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataOptionsMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataOptionsTypeMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataOptionsTypeMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataOptionsTypeMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataOptionsValueMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataOptionsValueMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataOptionsValueMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftCollectionMetadataOptionsSubValueMaxLength", wireType)
			}
			m.ValidNftCollectionMetadataOptionsSubValueMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftCollectionMetadataOptionsSubValueMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidNftId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataMaxCount", wireType)
			}
			m.ValidNftMetadataMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataTitleMaxLength", wireType)
			}
			m.ValidNftMetadataTitleMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataTitleMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataDescriptionMaxLength", wireType)
			}
			m.ValidNftMetadataDescriptionMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataDescriptionMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataImagesMaxCount", wireType)
			}
			m.ValidNftMetadataImagesMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataImagesMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataImagesTypeMaxLength", wireType)
			}
			m.ValidNftMetadataImagesTypeMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataImagesTypeMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataLinksMaxCount", wireType)
			}
			m.ValidNftMetadataLinksMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataLinksMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataLinksTypeMaxLength", wireType)
			}
			m.ValidNftMetadataLinksTypeMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataLinksTypeMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataAttributesMaxCount", wireType)
			}
			m.ValidNftMetadataAttributesMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataAttributesMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataAttributesTypeMaxLength", wireType)
			}
			m.ValidNftMetadataAttributesTypeMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataAttributesTypeMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataAttributesValueMaxLength", wireType)
			}
			m.ValidNftMetadataAttributesValueMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataAttributesValueMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidNftMetadataAttributesSubValueMaxLength", wireType)
			}
			m.ValidNftMetadataAttributesSubValueMaxLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidNftMetadataAttributesSubValueMaxLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidBurnNftMaxCount", wireType)
			}
			m.ValidBurnNftMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidBurnNftMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
